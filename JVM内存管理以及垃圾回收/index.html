<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JVM内存管理以及垃圾回收 | Shea's Blog</title><meta name="keywords" content="JVM"><meta name="author" content="Shea"><meta name="copyright" content="Shea"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="Java 内存结构以及垃圾回收内存结构java7">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM内存管理以及垃圾回收">
<meta property="og:url" content="http://example.com/JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%BB%A5%E5%8F%8A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/index.html">
<meta property="og:site_name" content="Shea&#39;s Blog">
<meta property="og:description" content="Java 内存结构以及垃圾回收内存结构java7">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/yinuxy/cdn/raw/master/2020/10/30/10eae0a4cff093b39b97ad741a4bd2f1.png">
<meta property="article:published_time" content="2020-10-09T02:51:00.000Z">
<meta property="article:modified_time" content="2020-10-09T10:49:12.533Z">
<meta property="article:author" content="Shea">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/yinuxy/cdn/raw/master/2020/10/30/10eae0a4cff093b39b97ad741a4bd2f1.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%BB%A5%E5%8F%8A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Shea","link":"链接: ","source":"来源: Shea's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: {"text":"富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善","fontSize":"15px"},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-10-09 18:49:12'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'true'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tzki/tzki.github.io/css/pool.css"><meta name="generator" content="Hexo 5.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://gitee.com/yinuxy/cdn/raw/master/2020/10/30/10eae0a4cff093b39b97ad741a4bd2f1.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Shea's Blog</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">JVM内存管理以及垃圾回收</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-10-09T02:51:00.000Z" title="发表于 2020-10-09 10:51:00">2020-10-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-10-09T10:49:12.533Z" title="更新于 2020-10-09 18:49:12">2020-10-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JVM/">JVM</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="Java-内存结构以及垃圾回收"><a href="#Java-内存结构以及垃圾回收" class="headerlink" title="Java 内存结构以及垃圾回收"></a>Java 内存结构以及垃圾回收</h3><h4 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h4><h5 id="java7"><a href="#java7" class="headerlink" title="java7"></a>java7</h5><p><img src= "/img/loading.gif" data-lazy-src="/.com//java7%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png"></p>
<a id="more"></a>
<p><img src= "/img/loading.gif" data-lazy-src="/.com//JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/.com//TIM%E5%9B%BE%E7%89%8720190715103024.png"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/.com//TIM%E5%9B%BE%E7%89%8720190715103134.png"></p>
<p>一般将-Xmx -Xms 设置为一样，因为当heap不够用进行扩容时会发生抖动，影响程序运行的稳定性。</p>
<p><img src= "/img/loading.gif" data-lazy-src="/.com//TIM%E5%9B%BE%E7%89%8720190715103431.png"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/.com//TIM%E5%9B%BE%E7%89%8720190715103647.png"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/.com//TIM%E5%9B%BE%E7%89%8720190715103910.png"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/.com//TIM%E5%9B%BE%E7%89%8720190715104149.png"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/.com//TIM%E5%9B%BE%E7%89%8720190715104258.png"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/.com//TIM%E5%9B%BE%E7%89%8720190715104408.png"></p>
<p>JDK6：当调用intern方法时，如果字符串常量池先前已创建出该字符串对象，则返回池中该字符串的引用，否则，将此字符串对象添加到<u>字符串常量池</u>中，并且返回该字符串的引用。</p>
<p>JDK6+：当调用intern方法时，如果字符串常量池先前已创建出该字符串对象，则返回池中该字符串的引用，否则，如果字符串对象已经存在于==Java堆==中，则将堆中的对此对象的引用添加到字符串常量池中，并且返回该引用，如果堆中不存在，则在池中创建该字符串并返回其引用</p>
<p><img src= "/img/loading.gif" data-lazy-src="/.com//TIM%E5%9B%BE%E7%89%8720190715112834.png"></p>
<h5 id="程序计数器-Program-Counter-Register"><a href="#程序计数器-Program-Counter-Register" class="headerlink" title="程序计数器(Program Counter Register)"></a>程序计数器(Program Counter Register)</h5><ul>
<li><code> 线程私有。代码的运行时有顺序的，但当cpu在多线程切换时，当从A线程切换到B线程，在切回到A线程时，cpu如何知道该从A线程的哪里继续执行呢？cpu工作时就是根据每个线程的程序计数器的值来选取下一条需要执行的字节码指令，即“找到它离开时的位置来继续执行”。需要提示的是，当CPU执行的是一个Java方法时，程序计数器记录的是正在执行的虚拟机字节码指令的地址。如果执行的是Native方法（java调用非java代码的接口），这个计数值为undefined，即不发挥作用</code></li>
</ul>
<ul>
<li><code>程序计数器是线程私有的一块较小的内存空间，直接划分在CPU上，程序员无法直接操作它。作用：JVM在解释字节码文件（.class）时，存储当前线程所执行的字节码的行号。是一种概念模型，各种JVM所采取的方式不同。</code></li>
</ul>
<ul>
<li><code>是唯一一个在Java规范中没有任何OutOfMemoryError情况的区域</code></li>
</ul>
<ul>
<li><code>分支、循环、跳转等基础功能都是依赖此技术区完成的</code></li>
</ul>
<ul>
<li><code>线程时CPU调度的基本单位，多线程情况下，线程数超过CPU内核数量时，线程之间就要根据时间片轮询抢夺CPU时间资源，因此，为了线程切换后能够恢复到正确的执行位置，每条线程都需要一个独立的程序计数器去记录正在执行的字节码指令地址</code></li>
</ul>
<h5 id="虚拟机栈-JVM-Stacks"><a href="#虚拟机栈-JVM-Stacks" class="headerlink" title="虚拟机栈(JVM Stacks)"></a>虚拟机栈(JVM Stacks)</h5><p><code>是描述Java方法执行的内存模型</code></p>
<p><code>线程私有。JVM虚拟机栈就是我们常说的堆栈的栈（我们常常把内存粗略的分为堆和栈），生命周期和线程一样，每个方法被执行的时候都会产生一个栈帧，用于存储局部变量表，动态链接、操作数、方法出口等信息。</code></p>
<p><code>方法的执行过程就是栈帧在JVM中出栈和入栈的过程</code></p>
<p><code>局部变量表中存放的是各种基本数据类型，如：（int, short, long, byte, float, double, boolean, char）和 对象句柄（即引用类型（存放的是指向个个对象的内存地址））。他们可以是方法参数，也可以是方法的局部变量。因此，他有一个特点，内存空间可以在编译期间就确定，运行期不在改变。这个区域有两种可能的Java异常：StackOverFlowError和OutOfMemporyError</code></p>
<p><code>我们知道，一个线程拥有一个自己的栈，这个栈的大小决定了方法调用的可达深度（递归多少层次，或者嵌套调用多少层其他方法，-Xss参数可以设置虚拟机栈大小），若线程请求的栈深度大于虚拟机允许的深度，则抛出StackOverFlowError异常。</code></p>
<p>==栈的大小可以使固定的，也可以是动态扩展的，若虚拟机可以动态扩展（大多数虚拟机都可以），但拓展时无非申请到足够的内存（比如没有足够的内存为一个新创建的线程分配栈空间时）则抛出OutofMemoryError异常==</p>
<p>栈帧结构图：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdn.net/20170505082120037?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>
<h5 id="本地方法栈-Native-Method-Stacks"><a href="#本地方法栈-Native-Method-Stacks" class="headerlink" title="本地方法栈(Native Method Stacks)"></a>本地方法栈(Native Method Stacks)</h5><p><code>本地方法栈就是用来处理Java中的本地方法的，java类的祖先类Object中有众多的Native方法，如hashCode()、wait()等，他们的执行很多时候是借助于操作系统，但是JVM需要对他们做一些规范，来处理他们的执行过程。</code></p>
<p><code>本地方法栈与虚拟机栈发挥的作用是非常相似的，他们之间的区别不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈为虚拟机执行Native方法服务。与虚拟机栈一样，本地方法栈区域也会抛出 StackOverflowError 和 OutOfMemoryError 异常。</code></p>
<p><code>由于虚拟机规范对于本地方方法栈的具体实现没有强制要求，所以可以有不同的实现方法，比如Sun HotSpot直接把本地方法栈和虚拟机栈合二为一</code></p>
<h5 id="Java堆-Head"><a href="#Java堆-Head" class="headerlink" title="Java堆(Head)"></a>Java堆(Head)</h5><p>堆内存是java内存模型中最重要的一块，也是最有必要进行深究的一部分，因为java性能的优化主要就是针对这部分。涉及到内存的分配(new 关键字、反射等)与回收(回收算法，收集器等)。</p>
<p>堆的唯一目的就是==存放对象实例==，几乎所有的对象实例（和数组）都在这里分配内存。类的对象从中分配空间，这些对象通过new、newarray、anewarray和multianewarray等指令建立，他们不需要程序代码来显示的释放。</p>
<p>java规范中的描述：所有对象实例以及数组都要在堆上分配。</p>
<p>线程共享</p>
<p>线程共享的Java堆可能分出<u>多个线程私有的分配缓冲区</u>(<strong>TLAB</strong>,这是为了并发分配内存时的脏分配问题，需要使用相关参数来开启。虚拟机默认使用CAS加上失败重试机制解决脏分配问题)</p>
<p>Java堆在HotSpot中的实现是可拓展的</p>
<p>由于Java堆唯一目的就是用来存放对象实例，因此其也是垃圾收集器管理的主要区域，故也称为GC堆</p>
<p>从内存回收的角度看，由于现在的垃圾收集器基本都采用<strong>分代收集</strong>算法，所以为了方便垃圾回收，Java堆还可以分为<strong>新生代和老年代</strong>。</p>
<p>新生代用于存放刚创建的对象以及年轻的对象，如果对象一直么有被回收，生存的足够长，对象就会被移入老年代，新生代有可进一步细分为 eden、survivorSpace0和survivorSpace1。刚创建的对象都放入eden,s0、s1都至少经过一次GC并幸存。如果幸存对象经过一定时间仍存在，则进入老年代。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdn.net/20170505083056192?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>
<p><code>java堆可以处在物理上不连续的内存空间中，只要逻辑上是连续的即可。</code></p>
<h6 id="TLAB-Thread-Local-Allocation-Buffer-线程私有分配缓冲区"><a href="#TLAB-Thread-Local-Allocation-Buffer-线程私有分配缓冲区" class="headerlink" title="TLAB(Thread Local Allocation Buffer,==线程私有分配缓冲区==)"></a>TLAB(Thread Local Allocation Buffer,==线程私有分配缓冲区==)</h6><p>Sun Hotspot JVM 为了提升对象内存分配的效率，对于所创建的线程，都会分配一块堆里的空间TLAB，其大小由JVM根据运行的情况计算而得。在TLAB上分配对象时<u>不需要加锁</u>（相对于CAS配上失败重试方式），因此JVM再给线程的对象分配内存时会尽量的在TLAB上分配，在这种情况下JVM中分配对象内存的性能和C基本上是一样高效的，但如果对象过大的话则仍然是直接使用堆空间分配。</p>
<p>虚拟机为新生对象分配内存时，需要考虑修改指针 (该指针用于划分内存使用空间和空闲空间) 时的线程安全问题，因为存在可能出现正在给对象A分配内存，指针还未修改，对象B又同时使用原来的指针分配内存的情况。TLAB 的存在就是为了解决这个问题：每个线程在Java堆中预先分配一小块内存 TLAB，<strong>哪个线程需要分配内存就在自己的TLAB上进行分配</strong>，若TLAB用完并分配新的TLAB时，再加同步锁定，这样就大大提升了对象内存分配的效率</p>
<h5 id="方法区-永久代、Method-Area-（1-7）"><a href="#方法区-永久代、Method-Area-（1-7）" class="headerlink" title="方法区(永久代、Method Area)（1.7）"></a>方法区(永久代、Method Area)（1.7）</h5><p>方法区是所有线程共享的内存区域，用于存储==已经被JVM加载的类信息、常量、静态变量等数据==。</p>
<p>java规范将方法区描述为堆的一个逻辑部分，但是它不是堆，又称为非堆</p>
<p><strong>运行时常量池</strong> :（1.7以后在堆中）方法区重要概念，主要用于存放==在编译过程中就产生的字面量和符号引用==。其中，字面量比较接近Java语言层次的常量概念，如<u>文本字符串、被声明为final的常量值</u>等；而符号引用则属于编译原理方面的概念，包括以下三类常量：<u>类和接口的全限定名、字段的名称和描述符 和 方法的名称和描述符</u>。一般情况下，常量的内存分配在编译期间就能明确，但不一定全是。<u>有一些可能就是运行时==也可将常量放入常量池，如String类中有个Native方法intern()</u></p>
<p>运行时常量池相对于Class文件常量池的一个重要特征是<u>具备动态性</u>。</p>
<h5 id="元空间（MetaSpace）（1-8）与永久代（PermGen）的区别"><a href="#元空间（MetaSpace）（1-8）与永久代（PermGen）的区别" class="headerlink" title="元空间（MetaSpace）（1.8）与永久代（PermGen）的区别"></a>元空间（MetaSpace）（1.8）与永久代（PermGen）的区别</h5><p>java 8以后开始把类的元数据放在本地==堆==内存中，这一块区域就叫做==元空间== 。该区域在jdk1.7及以前是属于==永久代==的，元空间以及永久代都是用来<u>存储class的相关信息</u>，包括class对象的·method以及field。<u>这两个都系都是方法区的实现</u>，只是实现方法不同。<u>方法区只是jvm的规范</u>。在java7后原先位于方法区中的字符串常量池被移动到了java堆中并且在java8以后用==元空间替代了永久代==。</p>
<p>最大区别：==元空间使用本地内存、而永久代使用的是jvm内存==。这个替代的表现就为，在老版本jdk中java.lang.OutOfmemoryError:PermGen space这个异常不复存在。因为默认的类的元数据分配只收本地内存大小的限制。也就是理论上本地内存有多少，metaSpace就有多大。</p>
<p>替换优势：字符串常量池存在永久代中，==<u>容易出现性能问题和内存溢出</u>==。类和方法的信息大小难以确定，给永久代的大小指定带来了困难。永久代会为GC带来不必要的复杂性。方便HotSpot与其他JVM如Jrockit集成（其他的jvm没有永久代这一说）</p>
<h5 id="Java堆和方法区的区别"><a href="#Java堆和方法区的区别" class="headerlink" title="Java堆和方法区的区别"></a>Java堆和方法区的区别</h5><p>Java堆是Java代码可及的内存，是留给开发人员使用的；而<u>==非堆（Non-Heap）是JVM留给自己用的==</u>，所以方法区、jvm内部处理或优化所需内存（如JIT编译后的代码缓存）、每个类结构（如运行时常量池、字段、方法数据）以及方法和构造方法的代码都在非堆内存中</p>
<h5 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h5><p>方法区的内存回收目标主要是针对==<u>常量池的回收和对类型的卸载</u>==。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，例如一个字符串“abc”已经进入了常量池中，但是当前系统没有一个String对象是叫做“abc”的，换句话说是没有任何String对象==引用==常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果在这时候发生内存回收，而且必要的话，这个“abc”常量就会被系统“请”出常量池，常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p>
<p>判断一个常量是否是“废弃常量”比较简单，而要判断一个类是否是“==无用的类==”的条件则相对苛刻许多，类需要同时满足下面三个条件才能算是“无用的类”</p>
<ul>
<li><u>该类所有的==实例都已经被回收==，也就是Java<strong>堆</strong>中不存在该类的任何实例；</u></li>
<li><u>加载该类的==ClassLoader==已经被回收</u></li>
<li><u>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过==反射==访问该类的方法。</u></li>
</ul>
<p>​      虚拟机可以对满足上述3个条件的无用类进行回收(卸载)，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会回收。特别地，在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出</p>
<h5 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h5><p>直接内存不是Java虚拟机规范的内存区域。但是这部分也被人频繁使用，会导致OutOfMemory异常</p>
<p>JDK1.4中加入的==NIO==，引入了一种<strong>基于通道与缓冲区的I/O方式</strong>，它们==可以使用Native函数库直接分配堆外内存==，即我们所说的直接内存，这样在某些场景中会提高程序的性能</p>
<h4 id="内存模型概述"><a href="#内存模型概述" class="headerlink" title="内存模型概述"></a>内存模型概述</h4><p>Java程序在执行前首先会被编译成字节码文件，然后再有Java虚拟机执行这些字节码文件从而使得Java程序得以执行。在程序执行过程中，内存的使用和管理一直是值得关注的问题，Java虚拟机在执行java程序的工程中会把它所管理的内存划分为若干个不同的数据区域，这些数据区域都有各自的用途，以及创建和销毁的时间</p>
<h5 id="数据区域两种类型"><a href="#数据区域两种类型" class="headerlink" title="数据区域两种类型"></a>数据区域两种类型</h5><ul>
<li>线程共享：方法区和堆</li>
<li>线程私有：虚拟机栈、本地方法栈、程序计数器</li>
</ul>
<h4 id="垃圾回收（Garbage-Collection-GC）"><a href="#垃圾回收（Garbage-Collection-GC）" class="headerlink" title="垃圾回收（Garbage Collection,GC）"></a>垃圾回收（Garbage Collection,GC）</h4><h5 id="为什么要进行垃圾回收"><a href="#为什么要进行垃圾回收" class="headerlink" title="为什么要进行垃圾回收"></a>为什么要进行垃圾回收</h5><p>随着程序的运行，内存中存在的实例对象、变量等信息占据的内存越来越多。如果不及时进行垃圾回收，必然会带来==程序性能==的下降，甚至会因为可用内存不足造成一些不必要的系统异常</p>
<h5 id="哪些垃圾需要回收"><a href="#哪些垃圾需要回收" class="headerlink" title="哪些垃圾需要回收"></a>哪些垃圾需要回收</h5><p>在以上的几大区中，有三个是不需要进行垃圾回收的：程序计数器、JVM栈、本地方法栈。因为他们的声明周期适合线程同步的，随着线程的销毁，他们占用的内存会自动释放，所以==只有方法区和堆需要进行GC==。具体到哪些对象的话，简单概括一句话：如果那个对象已经不存在任何引用，那么他可以被回收。通俗解释一下就是说，如果一个对象，已经没有什么作用了，就可以被当成废弃物被回收了。</p>
<h5 id="什么时候进行垃圾回收"><a href="#什么时候进行垃圾回收" class="headerlink" title="什么时候进行垃圾回收"></a>什么时候进行垃圾回收</h5><p>堆的新生代、老年代、永久代的垃圾回收时机，MinorGC和FullGC</p>
<p>根据一个经典的引用计数算法，每个对象添加一个<u>引用计数器</u>，每被引用一次，计数器加一，失去引用，计数器减一，当计数器在一段时间内保持为0时，该对象就认为是可以被回收的了。但是这个算法有明显的缺陷，当两个对象<u>相互引用</u>，但是两者已经没有作用时，按照常规，应该对其进行垃圾回收，但是其相互引用，又不符合此算法回收的条件，因此无法完美的处理这块内存清理。因此Sun的JVM并没有采用引用计数算法来进行垃圾回收。而是采用一个叫：==根搜索算法（可达性分析算法）==，如下图：</p>
<p><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/Rico123/q0t6nxkafapyn6yql7benc32/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg"></p>
<p>基本思想就是：从一个GC Roots的对象开始，向下搜索，如果==一个对象不能到达GCRoots对象==的时候，说明他已经不在被<strong>引用</strong>，即可被进行垃圾回收（此处暂时这样理解，其实事实还有一些不同，当一个对象不在被引用时，并没有完全“死亡”，<u>如果类重写了finalize()方法，且没有被系统调用过，那么该对象可以“重生”</u>，如果不可以，那么说明彻底可以被回收了），如上图中的ObjectF、ObjectD、ObjectE，虽然他们三个依然可能相互引用，但是总体来说，他们已经没有作用了，这样就解决了引用计数算法无法解决的问题。</p>
<p>在Java中，可作为GC Root的对象包括以下几种：</p>
<ul>
<li>虚拟机栈(栈帧中的局部变量表中引用的对象)</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中Native方法引用的对象；</li>
</ul>
<h5 id="补充“引用”的概念"><a href="#补充“引用”的概念" class="headerlink" title="补充“引用”的概念"></a>补充“引用”的概念</h5><p>JDK1.2之后，对引用进行了扩充，引入了强、软、弱、虚四种引用，被标记为这四种引用的对象，在GC时分别有不同的意义：</p>
<p>a. 强引用（Strong Reference）就是为刚被new出来的对象所加的引用，他的特点是，==永远不会被回收==。</p>
<p>b.软引用（soft Reference） 声明为软引用的类，是可以被回收的对象。如果JVM内存不紧张时这类对象可以不被回收，如果内存紧张则会被回收。那为什么会不直接回收了它，原因是：我们知道，Java中是存在缓存机制的，就拿字面量缓存来说，有些时候，缓存的对象就是当前可有可无的，只是留在内存中，==如果还有需要，则不需要重新分配内存即可使用==，因此，这些对象即可被引用为软引用，方便使用，提高程序性能。</p>
<p>c. 弱引用（Weak Reference）弱引用的对象就是==一定需要进行垃圾回收的==，不管内存是否紧张，当进行GC时，标记为弱引用的对象一定会被清理回收。</p>
<p>d.虚引用（Phantom Reference）虚引用弱的可以忽略不计，JVM完全不在乎虚引用，其唯一作用就是做一些跟踪记录，辅助finalize函数的使用。</p>
<h5 id="如何回收"><a href="#如何回收" class="headerlink" title="如何回收"></a>如何回收</h5><p><code>三种经典得垃圾回收算法（标志清除算法、复制算法、标记整理算法）以及分代收集算法和七种垃圾收集器</code></p>
<h5 id="Stop-the-World"><a href="#Stop-the-World" class="headerlink" title="Stop-the-World"></a>Stop-the-World</h5><p>这意味着JVM由于要执行GC而停止了应用程序的执行，并且这种情形会在任何一种GC算法中发生。当Stop-the-World发生时，除了GC所需要的线程外，所有线程都处于==等待状态==直到GC任务完成。事实上，GC优化很多时候就是指减少Stop-the-world发生的时间，从而使系统具有==高吞吐、低停顿==的特点。</p>
<p>内存泄漏是指该==内存空间使用完毕之后未回收==，在不涉及复杂数据结构的一般情况下，Java的内存泄漏表现为==一个内存对象的生命周期超出了程序需要它的时间长度==。</p>
<h5 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h5><p>1、标记清除算法</p>
<p>标记清除算法分为标记和清除两个阶段。该算法首先从==根集合==进行扫描，==对存活的对象进行标记==，标记完毕后，在扫描整个空间中==未被标记==的对象进行回收，如下图所示。</p>
<p><img src= "/img/loading.gif" data-lazy-src="/.com//%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.jpg"></p>
<p>标记-清除算法的主要不足有两个：</p>
<ul>
<li>效率问题：标记和清除两个过程的效率都不高；</li>
<li>空间问题：标记清除算法<u>不需要进行对象的移动，并且仅对不存活的对象进行处理</u>，因此标记清除之后会产生==大量不连续的内存碎片==，空间碎片太多可能会导致以后<u>在程序运行过程中需要分配较大对象时，无法找到足够的连续内存</u>，而不得不提前触发另一次垃圾收集动作。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="/.com//%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png"></p>
<p>2、复制算法</p>
<p>复制算法将==可用内存按照容量划分为大小相等的两块==，每次只是用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这种算法适用于==对象存活率低==的场景，比如==新生代==。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要==移动堆顶指针，按顺序分配内存==即可，实现简单，运行高效。复制算法示例图如下：</p>
<p><img src= "/img/loading.gif" data-lazy-src="/.com//%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.jpg"></p>
<p>事实上，现在商用的虚拟机都采用这种算法来回收新生代。因为研究发现，新生代中的对象每次回收基本上只有10%左右的对象存活，所以需要复制的对象很少，效率还不错。实践中会将新生代内存分为一块较大的Eden空间和两块较小的Survivor空间 (如下图所示)，==每次使用Eden和其中一块Survivor==。当回收时，将Eden和Survivor中还存活着的对象一次地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认==Eden和Survivor的大小比例是 8:1==，也就是每次新生代中可用内存空间为整个新生代容量的90% ( 80%+10% )，只有10% 的内存会被“浪费”。</p>
<p><img src= "/img/loading.gif" data-lazy-src="/.com//heap.bmp"></p>
<p>3、标记整理算法</p>
<p>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要额外的空间进行分配担保，以应对被使用的内存中==所有对象都100%存活的极端情况==，所以老年代一般不能直接选用这种算法。标记整理算法的标记过程类似标记清除算法，但后续步骤不是直接对可回收对象进行整理，而是让所有存活的对象都==向一端移动==，然后直接清理掉端边界以外的内存，类似于磁盘整理的过程，该垃圾回收算法适用于对象存活率高的场景（老年代），其作用原理如下图所示。</p>
<p><img src= "/img/loading.gif" data-lazy-src="/.com//%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%951.jpg"></p>
<p>标记整理算法与标记清除算法最显著的区别是：标记清除算法不进行对象的移动，并且仅对不存活的对象进行处理；而标记整理算法会将所有的存活对象移动到一端，并对不存活对象进行处理，因此其不会产生内存碎片。标记整理算法的作用示例图如下：</p>
<p><img src= "/img/loading.gif" data-lazy-src="/.com//%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p>
<p>4、分代收集算法</p>
<p>对于一个大型的系统，当创建的对象和方法变量比较多时，对内存中的对象也会比较多，如果逐一分析对象是否该回收，那么势必造成效率低下。分代收集算法是基于这样一个事实：不同的对象的生命周期（存活情况）是不一样的，而==不同生命周期的对象位于堆中不同的区域==，因此对堆内存不同区域采用不同的策略进行回收可以提高JVM的执行效率。当代商用虚拟机使用的都是分代收集算法：新生代对象存活率低，就采用复制算法；老年代存活率高就用标记清除算法或者标记整理算法。Java堆内存一般可以分为新生代、老年代。<u>老年代一般说归在方法区</u>（但是这种说法是不准确的）</p>
<p><img src= "/img/loading.gif" data-lazy-src="/.com//%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E6%80%BB.jpg"></p>
<h5 id="新生代、老年代、永久代详解"><a href="#新生代、老年代、永久代详解" class="headerlink" title="新生代、老年代、永久代详解"></a>新生代、老年代、永久代详解</h5><p>1、新生代（Young Generation）</p>
<p>新生代的目标就是尽可能快速的收集掉那些生命周期短的对象，一般情况下，所有新生成的对象都是放在新生代的，新生代内存按照==8:1:1==的比例分为一个 eden区和两个survivor(0,1)区，大部分对象在Eden区中生成。在进行垃圾回收时，==先将eden区存活对象复制到survivor0区然后清空eden区==，当这个survivor0区也满了时，==将eden区和survivor0区存活对象复制到survivor1区==，然后清空eden和这个survivor0区，此时survivor0区是空的，然后交换survivor0区和survivor1区的角色（即下次垃圾回收时会扫描Eden区和survivor1区），即==保持survivor0区是空的==，如此往复。特别的，当survivor1区也不足以存放eden区和survivor0区的存活对象时，就将存活对象==直接存放到老年代==。如果老年代也满了，就会触发一次==FullGC==,也就是新生代、老年代都进行回收。注意，新生代发生的GC也叫作MinorGC,MinorGC发生的频率比较高，不一定等Eden区满了才触发。</p>
<p>2、老年代（Old Generation）</p>
<p>老年代中存放的都是一些生命周期较长的对象，就像上面叙述的那样，==在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中==。此外==老年代的内存也比新生代大很多（大概是2:1）==当老年代满时会触发Major GC(Full GC)，老年代对象存活时间长，因此FullGC 发生的频率比较低。</p>
<p>3、永久代（Permanent Generation）</p>
<p>永久代主要用于存放==静态文件==，如Java类、方法等。永久代对垃圾回收没有显著影响，但是有些应用可能==动态生成或者调用一些class==，例如<u>反射，动态代理，CGLib等bytecode框架</u>时，在这种时候需要<u>设置一个比较大的永久代空间来存放这些运行过程中新增的类。</u></p>
<p>分代收集算法</p>
<p>safepoint</p>
<ul>
<li>分析过程中对象引用关系不会发生变化的点</li>
<li>产生safepoint的地方：方法调用；循环跳转；异常跳转</li>
<li>安全点数量得适中</li>
</ul>
<h5 id="垃圾回收算法总结"><a href="#垃圾回收算法总结" class="headerlink" title="垃圾回收算法总结"></a>垃圾回收算法总结</h5><p><img src= "/img/loading.gif" data-lazy-src="/.com//%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.png"></p>
<p>由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。垃圾回收有两种类型，Minor GC 和Full GC。</p>
<ul>
<li>Minor GC：对新生代进行垃圾回收，不会影响到老年代。因为新生代的Java对象大多都死亡频繁，所以MinorGC 非常频繁，一般在这里使用速度快、效率高的算法，使垃圾回收能尽快完成。</li>
<li>Full GC：也叫Major GC，对整个堆进行回收，包括新生代和老年代。由于Full GC 需要对整个堆进行回收，所以Minor GC要==慢==，因此应该尽可能减少Full GC的次数，导致Full GC 的原因包括：==老年代被写满、永久代（perm）被写满和Systen.gc()被显示调用==等。</li>
</ul>
<h5 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h5><p>垃圾收集器回收的是==无任何引用的对象占据的内存空间==而不是对象本身</p>
<p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是==内存回收的具体实现==。下图展示了其中作用于不同分代的收集器，其中用于**==回收新生代的收集器包括Serial、ParNew、Parallel Scavenge==<strong>,</strong>==回收老年代的收集器包括Serial Old、Paralled Old 、CMS==<strong>还有用于回收整个Java堆的</strong>==G1收集器==**。不同的收集器之间的连线表示他们可以搭配使用。</p>
<p><img src= "/img/loading.gif" data-lazy-src="/.com//%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg"></p>
<ul>
<li>【单线程–并行，并行×并行】</li>
<li>Serial 收集器（复制算法）：新生代单线程收集器，标记和清理都是单线程，优点是简单高效。</li>
<li>Serial Old收集器（标记-整理算法）：老年代单线程收集器，Serial收集器的老年代版本。</li>
<li>ParNew收集器（复制算法）：新生代并行收集器，实际上是==Serial收集器的多线程版本==，在多核CPU环境环境下有着比Serial更好的表现；</li>
<li>Parallel Scavenge收集器（复制算法）：新生代并行收集器，追求高吞吐量，高效利用CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台运用等对交互相应要求不高的场景。</li>
<li>Parallel Old 收集器（标记-整理算法）：老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；</li>
<li>CMS(Concurrent Mark Sweep) 收集器（==标记-清除算法==）：老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求GC回收停顿时间。</li>
<li>G1(Garbage First)收集器（标记-整理算法）：Java 堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G!收集器基于“标记-整理算法”实现，也就是说==不会产生内存碎片==。此外，G!收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆（包括新生代、老年代），而前六种收集器回收的范围仅限于新生代或老年代。</li>
</ul>
<h5 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h5><p>Java技术体系中所提倡的自动内存管理最终可以归结为自动化的解决了两个问题：给<strong>对象分配内存</strong>以及<strong>回收分配给对象的内存</strong></p>
<p>1、对象优先在Eden分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次MinorGC</p>
<p>2、==大对象直接进入老年代==。大对象是指需要大量连续内存空间的Java对象，最典型的大对象就是那种<u>很长的字符串以及数组</u></p>
<p>3、==长期存活的对象将进入老年代==。当对象在新生代中经历过一定次数（默认为15）的Minor GC后，就会被晋升到老年代中。</p>
<p>4、动态对象年龄判定。为了更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中==相同年龄==所有对象大小的总和==大于Survivor空间的一半==，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p>
<p>分代收集算法</p>
<p>触发Full GC的条件</p>
<ul>
<li>老年代空间不足</li>
<li>永久代空间不足</li>
<li>CMS GC时出现promotion failed，concurrent mode failure</li>
<li>Minor GC晋升到老年代的平均大小大于老年代的剩余空间</li>
<li>调用System.gc()</li>
<li>使用RMI来进行RPC或管理的JDK应用，每小时执行1次Full GC</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Shea</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%BB%A5%E5%8F%8A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">http://example.com/JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%BB%A5%E5%8F%8A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Shea's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/yinuxy/cdn/raw/master/2020/10/30/10eae0a4cff093b39b97ad741a4bd2f1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/Se7en/"><img class="prev-cover" data-lazy-src="https://gitee.com/yinuxy/cdn/raw/master/2020/10/30/10eae0a4cff093b39b97ad741a4bd2f1.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Se7en</div></div></a></div><div class="next-post pull-right"><a href="/%E5%AD%97%E7%AC%A6%E4%B8%B2/"><img class="next-cover" data-lazy-src="https://gitee.com/yinuxy/cdn/raw/master/2020/10/30/10eae0a4cff093b39b97ad741a4bd2f1.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">字符串</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/类加载机制/" title="类加载机制"><img class="cover" data-lazy-src="https://gitee.com/yinuxy/cdn/raw/master/2020/10/30/10eae0a4cff093b39b97ad741a4bd2f1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-01</div><div class="title">类加载机制</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Shea</div><div class="author-info__description">没什么值得畏惧，你唯一需要担心的是，你配不上自己的梦想，也辜负了曾经的苦难。</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Dxs-Shea" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:dxs_doris@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.</span> <span class="toc-text">Java 内存结构以及垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java7"><span class="toc-number">1.1.1.</span> <span class="toc-text">java7</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8-Program-Counter-Register"><span class="toc-number">1.1.2.</span> <span class="toc-text">程序计数器(Program Counter Register)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88-JVM-Stacks"><span class="toc-number">1.1.3.</span> <span class="toc-text">虚拟机栈(JVM Stacks)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-Native-Method-Stacks"><span class="toc-number">1.1.4.</span> <span class="toc-text">本地方法栈(Native Method Stacks)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Java%E5%A0%86-Head"><span class="toc-number">1.1.5.</span> <span class="toc-text">Java堆(Head)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#TLAB-Thread-Local-Allocation-Buffer-%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%E5%88%86%E9%85%8D%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">TLAB(Thread Local Allocation Buffer,&#x3D;&#x3D;线程私有分配缓冲区&#x3D;&#x3D;)</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA-%E6%B0%B8%E4%B9%85%E4%BB%A3%E3%80%81Method-Area-%EF%BC%881-7%EF%BC%89"><span class="toc-number">1.1.6.</span> <span class="toc-text">方法区(永久代、Method Area)（1.7）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%83%E7%A9%BA%E9%97%B4%EF%BC%88MetaSpace%EF%BC%89%EF%BC%881-8%EF%BC%89%E4%B8%8E%E6%B0%B8%E4%B9%85%E4%BB%A3%EF%BC%88PermGen%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.7.</span> <span class="toc-text">元空间（MetaSpace）（1.8）与永久代（PermGen）的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Java%E5%A0%86%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.8.</span> <span class="toc-text">Java堆和方法区的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9B%9E%E6%94%B6"><span class="toc-number">1.1.9.</span> <span class="toc-text">方法区的回收</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-number">1.1.10.</span> <span class="toc-text">直接内存</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.</span> <span class="toc-text">内存模型概述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%E4%B8%A4%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">数据区域两种类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88Garbage-Collection-GC%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">垃圾回收（Garbage Collection,GC）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.3.1.</span> <span class="toc-text">为什么要进行垃圾回收</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E9%9C%80%E8%A6%81%E5%9B%9E%E6%94%B6"><span class="toc-number">1.3.2.</span> <span class="toc-text">哪些垃圾需要回收</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%BF%9B%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.3.3.</span> <span class="toc-text">什么时候进行垃圾回收</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E2%80%9C%E5%BC%95%E7%94%A8%E2%80%9D%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.4.</span> <span class="toc-text">补充“引用”的概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9B%9E%E6%94%B6"><span class="toc-number">1.3.5.</span> <span class="toc-text">如何回收</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Stop-the-World"><span class="toc-number">1.3.6.</span> <span class="toc-text">Stop-the-World</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.7.</span> <span class="toc-text">垃圾收集算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E3%80%81%E8%80%81%E5%B9%B4%E4%BB%A3%E3%80%81%E6%B0%B8%E4%B9%85%E4%BB%A3%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.3.8.</span> <span class="toc-text">新生代、老年代、永久代详解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.9.</span> <span class="toc-text">垃圾回收算法总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.3.10.</span> <span class="toc-text">垃圾收集器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="toc-number">1.3.11.</span> <span class="toc-text">内存分配与回收策略</span></a></li></ol></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/%E5%8D%A2%E6%97%BA%E8%BE%BE%E9%A5%AD%E5%BA%97%20Hotel%20Rwanda%20(2004)/" title="Se7en"><img data-lazy-src="https://gitee.com/yinuxy/cdn/raw/master/2020/10/30/10eae0a4cff093b39b97ad741a4bd2f1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Se7en"/></a><div class="content"><a class="title" href="/%E5%8D%A2%E6%97%BA%E8%BE%BE%E9%A5%AD%E5%BA%97%20Hotel%20Rwanda%20(2004)/" title="Se7en">Se7en</a><time datetime="2020-10-18T07:13:37.000Z" title="发表于 2020-10-18 15:13:37">2020-10-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/mysql%E5%BC%95%E6%93%8E/" title="mysql引擎"><img data-lazy-src="https://gitee.com/yinuxy/cdn/raw/master/2020/10/30/10eae0a4cff093b39b97ad741a4bd2f1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mysql引擎"/></a><div class="content"><a class="title" href="/mysql%E5%BC%95%E6%93%8E/" title="mysql引擎">mysql引擎</a><time datetime="2020-10-12T01:33:53.000Z" title="发表于 2020-10-12 09:33:53">2020-10-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Se7en/" title="Se7en"><img data-lazy-src="https://gitee.com/yinuxy/cdn/raw/master/2020/10/30/10eae0a4cff093b39b97ad741a4bd2f1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Se7en"/></a><div class="content"><a class="title" href="/Se7en/" title="Se7en">Se7en</a><time datetime="2020-10-11T11:13:37.000Z" title="发表于 2020-10-11 19:13:37">2020-10-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%BB%A5%E5%8F%8A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" title="JVM内存管理以及垃圾回收"><img data-lazy-src="https://gitee.com/yinuxy/cdn/raw/master/2020/10/30/10eae0a4cff093b39b97ad741a4bd2f1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM内存管理以及垃圾回收"/></a><div class="content"><a class="title" href="/JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%BB%A5%E5%8F%8A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" title="JVM内存管理以及垃圾回收">JVM内存管理以及垃圾回收</a><time datetime="2020-10-09T02:51:00.000Z" title="发表于 2020-10-09 10:51:00">2020-10-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E5%AD%97%E7%AC%A6%E4%B8%B2/" title="字符串"><img data-lazy-src="https://gitee.com/yinuxy/cdn/raw/master/2020/10/30/10eae0a4cff093b39b97ad741a4bd2f1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="字符串"/></a><div class="content"><a class="title" href="/%E5%AD%97%E7%AC%A6%E4%B8%B2/" title="字符串">字符串</a><time datetime="2020-10-09T02:44:15.000Z" title="发表于 2020-10-09 10:44:15">2020-10-09</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 By Shea</div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://dxs-shea.github.io/about/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.spacingElementById('content-inner')
  else {
    $.getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js', () => {
      pangu.spacingElementById('content-inner')
    })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguFn)</script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/hideMobileSidebar.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" async="async" mobile="true"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":300,"height":350},"mobile":{"show":true},"log":false});</script></body></html>