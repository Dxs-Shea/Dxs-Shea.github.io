<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Redis持久化和缓存机制</title>
    <url>/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%92%8C%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>  说到redis，我们可能都会知道了他是一个类似缓存的一个内存数据库，我们从未感知到它的存在是因为他很快，为什么非常快，是因为他的发展到应用很快，还有他的反应速度也是非常快的。</p>
<a id="more"></a>
<h2 id="1-、Redis的适用环境"><a href="#1-、Redis的适用环境" class="headerlink" title="1 、Redis的适用环境"></a>1 、Redis的适用环境</h2><p>首先作为一个nosql的key—value组成的数据库，它们能存储的数据结构必须是简单的，因为有关系的数据即使存储进去之后查询也是很困难的，并且对于海量的数据存储还是关系型数据库比较合适。</p>
<p>举一个把一般数据库数据存储到key-value中的例子：</p>
<table>
<thead>
<tr>
<th>student</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>学号</td>
<td>姓名</td>
<td>年龄</td>
<td>班级</td>
</tr>
<tr>
<td>001</td>
<td>小明</td>
<td>18</td>
<td>2</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>key</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>student:001:姓名</td>
<td>小明</td>
</tr>
<tr>
<td>student:001:年龄</td>
<td>18</td>
</tr>
<tr>
<td>student:001:班级</td>
<td>2</td>
</tr>
</tbody></table>
<p>遵从规则为        key  表名：主键值：列名<br>​                            value  列值</p>
<p>如果加上表关系的话还要复杂好几倍的。</p>
<p>        那么什么样的数据适合存储在非关系型数据库中的呢？</p>
<p>        1、关系不是很密切的的数据，比如用户信息，班级信息，评论数量等等。</p>
<p>        2、量比较大的数据，如访问记录等</p>
<p>​    3、访问比较频繁的数据，如用户信息，访问数量，最新微博等</p>
<h2 id="2、持久化"><a href="#2、持久化" class="headerlink" title="2、持久化"></a>2、持久化</h2><p>那么这么多，这么重要的数据都存储在内存中，如果突然断电，岂不是很糟糕，于是就有了数据的持久化机制，这个其实就是把内存中的数据存储到硬盘中，方便数据的持续存在，也可以减少断电造成的损失。</p>
<p>  那么我们怎么持久化数据呢？多长时间进行一次持久化呢？</p>
<p>redis 支持两种持久化方式，一种是 Snapshotting（快照）也是默认方式，另一种是 Append-only file（缩写 aof）的方式。下面分别介绍：</p>
<h3 id="2-1-Snapshotting"><a href="#2-1-Snapshotting" class="headerlink" title="2.1 Snapshotting"></a>2.1 Snapshotting</h3><p>​      快照是默认的持久化方式。这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。可以通过配置设置自动做快照持久化的方式。我们可以配置 redis在 n 秒内如果超过 m 个 key 被修改就自动做快照，下面是默认的快照保存配置：</p>
<ul>
<li>save 900 1 #900 秒内如果超过 1 个 key 被修改，则发起快照保存</li>
<li>save 300 10 #300 秒内容如超过 10 个 key 被修改，则发起快照保存</li>
<li>save 60 10000</li>
</ul>
<p>下面介绍详细的快照保存过程：</p>
<ol>
<li>redis 调用 fork,现在有了子进程和父进程。</li>
<li>父进程继续处理 client 请求，子进程负责将内存内容写入到临时文件。由于 os 的实时复制机制（ copy on write)父子进程会共享相同的物理页面，当父进程处理写请求时 os 会为父进程要修改的页面创建副本，而不是写共享的页面。所以子进程地址空间内的数据是 fork时刻整个数据库的一个快照。</li>
<li>当子进程将快照写入临时文件完毕后，用临时文件替换原来的快照文件，然后子进程退出。client 也可以使用 save 或者 bgsave 命令通知 redis 做一次快照持久化。 save 操作是在主线程中保存快照的，由于 redis 是用一个主线程来处理所有 client 的请求，这种方式会阻塞所有client 请求。所以不推荐使用。另一点需要注意的是，每次快照持久化都是将内存数据完整写入到磁盘一次，并不是增量的只同步变更数据。如果数据量大的话，而且写操作比较多，必然会引起大量的磁盘 io 操作，可能会严重影响性能。</li>
</ol>
<h3 id="2-2-AOF-方式"><a href="#2-2-AOF-方式" class="headerlink" title="2.2 AOF 方式"></a>2.2 AOF 方式</h3><p>  由于快照方式是在一定间隔时间做一次的，所以如果 redis 意外 down 掉的话，就会丢失最后一次快照后的所有修改。如果应用要求不能丢失任何修改的话，可以采用 aof 持久化方式。</p>
<p>下面介绍 Append-only file:aof 比快照方式有更好的持久化性，是由于在使用 aof 持久化方式时,redis 会将每一个收到的写命令都通过 write 函数追加到文件中(默认是 appendonly.aof)。</p>
<p>当 redis 重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。当然由于 os 会在内核中缓存 write 做的修改，所以可能不是立即写到磁盘上。这样 aof 方式的持久化也还是有可能会丢失部分修改。不过我们可以通过配置文件告诉 redis 我们想要通过 fsync 函数强制 os 写入到磁盘的时机。有三种方式如下（默认是：每秒 fsync 一次）</p>
<ul>
<li>appendonly yes //启用 aof 持久化方式</li>
<li># appendfsync always //收到写命令就立即写入磁盘，最慢，但是保证完全的持久化</li>
<li>appendfsync everysec //每秒钟写入磁盘一次，在性能和持久化方面做了很好的折中</li>
<li># appendfsync no //完全依赖 os，性能最好,持久化没保证</li>
</ul>
<p>aof 的方式也同时带来了另一个问题。持久化文件会变的越来越大。例如我们调用 incr test命令 100 次，文件中必须保存全部的 100 条命令，其实有 99 条都是多余的。因为要恢复数据库的状态其实文件中保存一条 set test 100 就够了。为了压缩 aof 的持久化文件。 redis 提供了 bgrewriteaof 命令。收到此命令 redis 将使用与快照类似的方式将内存中的数据以命令的方式保存到临时文件中，最后替换原来的文件。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串在java中无非String、StringBuilder、StringBuffer</p>
<p>三者效率比较：StringBuilder &gt; StringBuffer &gt; String,这个比较是相对的，再做大量的对同一字符串进行操作时，这个效率排名一般是正确的，但是当对字符串的操作很少时，比如 String str = “hello” + “world”的效率要高于 StringBuilder str = new StringBuilder().append(“hello”).append(“world”)</p>
<a id="more"></a>
<h4 id="使用选择方式"><a href="#使用选择方式" class="headerlink" title="使用选择方式"></a>使用选择方式</h4><ul>
<li>当字符串相加操作或者改动较少时，建议使用String str = “hello”的形式</li>
<li>当字符串相加操作较多的情况下建议使用StringBuilder。如果使用了多线程，则使用StringBuffer</li>
</ul>
<h4 id="与equals"><a href="#与equals" class="headerlink" title="==与equals"></a>==与equals</h4><p><code>equals比较的是对象的内容也就是JVM堆内存中的内容，==比较的是地址即JVM栈内存中的内容</code></p>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><ul>
<li>string声明的字符串长度不可变是与StringBuilder与SringBuffer的最直观的区别。</li>
<li>string通过char数组保存字符串</li>
<li>对String对象的任何改变都不影响到原对象，任何的change操作都会生成新对象，比如substring,concat或replace在源码中的操作都不是在原有字符串上进行的么事重新生成了一个新的字符串对象。</li>
<li>string类的源码中 被final修饰  不能被继承（早起final修饰的方法会被转为内嵌调用以提升执行效率，现在的版本中已经渐渐被摒弃，所以现在不需要考虑用final去提升方法调用效率。只有不想让该方法被覆盖时才将方法设置为final）</li>
<li>类似 String s = “hello,world”创建时会在JVM的栈内存中产生一个变量 s ，同时在堆内存中产生”hello,world“字符串对象，s指向hello,world的内存地址。像上面这种方式产生的字符串属于<strong>直接量字符串</strong> (直接赋值的这种类型，<em>new String(“hello,world”)不会产生缓存,new关键字来生成对象都是在堆区进行的。而在堆区进行对象生成的过程是不会去检测对象是否已经存在的，因此通过new来创建对象，创建出的一定是不同的对象，及时字符串的内容是相同的</em>)对象，JVM在处理这类字符串的时候，会进行缓存，产生时放入字符串池，当程序需要再次使用的时候，无需重新创建一个新的字符串，而是直接指向已存在的字符串。如下代码打印结果为 true：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">        String s1 = <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;hello&quot;</span></span><br><span class="line">        String s3 = s2 + <span class="string">&quot;,world&quot;</span>;</span><br><span class="line">        System.out.println(s == s3);<span class="comment">//false</span></span><br><span class="line">        System.out.pringln(s.equals(s3));<span class="comment">//true</span></span><br><span class="line">        <span class="keyword">final</span> String s4 = <span class="string">&quot;hello&quot;</span>;<span class="comment">//对于被final修饰的变量，堆在class文件常量池中保存一个副本，也就是说不会通过连接而进行访问，对final边量的访问在编译期间都会直接被替代为真实的值。所以 String s5 = s4 + &quot;,world&quot;，实际上被JVM优化为 String s5 = &quot;hello&quot; +&quot;,world&quot;；等同于 String s5 = &quot;hello,world&quot;;但是如果final修饰的变量的结果是在运行时才能确定的，则 s4与s不是同一个对象</span></span><br><span class="line">        String s5 = s4 + <span class="string">&quot;,world&quot;</span>;</span><br><span class="line">      	String s6 = s2.concat(<span class="string">&quot;,world&quot;</span>);<span class="comment">//从末尾拼接</span></span><br><span class="line">        System.out.println(s == s5);<span class="comment">//true</span></span><br><span class="line">        System.out.println(s.equals(s5));<span class="comment">//true</span></span><br><span class="line">      	System.out.println(s == s6);<span class="comment">//false</span></span><br><span class="line">      	System.out.println(s.equals(s6))<span class="comment">//true</span></span><br><span class="line">        System.out.println(s == s1);<span class="comment">//true</span></span><br><span class="line">        String s7 = <span class="keyword">new</span> String(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">        String s8 = s7.intern();<span class="comment">//当调用s.intern()这句的时候，先去字符串常量池中找，是否有abc这个串，如果没有，则新增，同时返回引用，如果有，则返回已经存在的引用;</span></span><br><span class="line">        System.out.println(s == s7);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s == s8);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>用上述方法声明的string对象是固定的但是其所指向的对象可以发生变化，即s是引用变量。当声明s后，如出现 s = s +”a”;代码  则 s指向 ”hello,worlda“此字符串，但是s对象未发生变化，只是指向的对象发生变化。</p>
</li>
<li><p>String初始化方式(常用)</p>
<p>①  String s = “hello,world” 属于直接量字符串，并且当 String s1 = “hello,world”出现在同一代码段中时，s == s1 &amp;&amp; s.equlas(s2)。因为 直接量的字符串会产生缓存池，所以，当声明s1的时候，编译器检测到缓存池中存在相同的字符串，所以就直接使用。两者栈内存地址相同，并且堆内存指向的内容相同。</p>
<p>② String()  初始化一个String对象，表示一个空字符序列</p>
<p>③String(String value) 利用一个直接量创建一个新串</p>
<p>④String(char[] value) 利用一个字符数组创建</p>
<p>⑤String(char[] value,int offset,int count) 截取字符数组，从offset开始count个字符创建</p>
<p>⑥String(StringBuffer buffer);等同于 buffer.toString(); 同StringBuilder;`</p>
</li>
<li><p>字符串比较大小</p>
<p>从第一位开始  两个字符串同时比较字符的ASCII码值；如 a &lt; bc 、  ac&lt;bc 、  b&gt; ac </p>
</li>
</ul>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul>
<li><p><strong>String s = “123” + “456”内存中产生几个字符串对象？</strong></p>
<p>因为前面提到Java字符串的缓存，编译器在编译的时候会进行优化，所以 “123”与“456”被合成一个串“123456”,所以如果缓存池中没有“123456”这个对象，则会产生一个，且栈中产生一个引用s指向他，如果已存在那么产生0个对象，直接用s指向它。</p>
</li>
</ul>
<ul>
<li><p><strong>如果spilt()函数的参数在要分割的字符串中没有怎么办？如String s = “helloworld” ,我现在调用String[] s2 = s.spilt(“abc”)，返回什么？</strong></p>
<p>s2 为 helloworld</p>
</li>
</ul>
<ul>
<li><p><strong>判断</strong></p>
<p>String s = “ab” ; String s1 = “a”; String s2 = s1 +”b” ; String s3 = “ab”;</p>
<p><strong>s == s3 —&gt; true</strong></p>
<p><strong>s == s2 —&gt;false</strong>  s1+”b”产生了新对象 ， 栈内存中的地址不相同</p>
<p><strong>s.equals(s2) —&gt;true</strong>  堆内存的内容相同 </p>
</li>
<li><p><strong>String str = new String(“abc”)产生几个对象</strong></p>
<p>在运行期间创建一个对象，即在堆上创建了“abc”对象。涉及到两个对象，还有一个是在类加载的过程中在运行时常量池中创建了一个“abc”对象</p>
</li>
</ul>
<ul>
<li><p><strong>String str1 = “I”; str1 += “love” + “java”</strong>(1)和<strong>String str1 = “I”; str1 = str1 + “love” + “java”</strong>(2)的区别</p>
<p>1的效率比2高，1中的“love”+”java”在编译期间会被优化成“lovejava”而2中的不会被优化。前面说到过 s +=”hello”会被优化为StringBuilder 1会进行1次append而2会进行两次append操作</p>
</li>
</ul>
<h4 id="StringBuffer与StringBuilder"><a href="#StringBuffer与StringBuilder" class="headerlink" title="StringBuffer与StringBuilder"></a>StringBuffer与StringBuilder</h4><p><code>与String不同，StringBuffer与StringBuilder类的对象能够被多次的修改，并且不产生新的对象。</code></p>
<p><code>StringBuilder和StringBuffer类拥有的成员属性以及成员方法基本相同</code></p>
<p><code>StringBuilder与StringBuffer之间最大的不同是在于StringBuilder的方法不是线程安全的（不能同步访问）体现在StringBuffer在类的成员方法前面对了一个关键字：synchronized </code></p>
<p><code>StringBuilder比StringBuffer有速度优势，所以多数情况建议使用StringBuilder类，然而在程序要求线程安全的情况下，必须使用StringBuffer类</code></p>
<p><code>string+=&quot;hello&quot;的操作事实上会被JVM优化成</code></p>
<p><code>StringBuider str = new StringBuilder(string);</code></p>
<p><code>str.append(&quot;hello&quot;);</code></p>
<p><code>str.toString();</code></p>
<p><code>所以对String生成的字符串进行操作时都会生成新对象，如果使再循环中进行字符串的操作，用String这种类型会产生大量的对象，如果不进行垃圾回收，会造成很大的内存资源浪费。</code></p>
<ol>
<li>append() 将指定的字符串追加到此字符串尾部</li>
<li>reverse() 反转字符串</li>
<li>delete(int start,int end) 移除次序列的子字符串中的字符</li>
<li>insert(int offset,object i) 将 object （int 、string、double。。。。）参数的字符串表示形式插入到此序列中</li>
<li>replace(int start,int end,String str) 使用给定String中的字符替换此序列的子字符串中的字符</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *代码示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStringBuffer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        stringBuffer.append(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        System.out.println(stringBuffer);</span><br><span class="line">        stringBuffer.reverse();</span><br><span class="line">        System.out.println(stringBuffer);</span><br><span class="line">        stringBuffer.delete(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        System.out.println(stringBuffer);</span><br><span class="line">        stringBuffer.insert(<span class="number">0</span>,<span class="string">&quot;6&quot;</span>);</span><br><span class="line">        System.out.println(stringBuffer);</span><br><span class="line">        stringBuffer.replace(<span class="number">6</span>,<span class="number">6</span>,<span class="string">&quot;asd&quot;</span>);</span><br><span class="line">        System.out.println(stringBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> *结果输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="number">123456</span></span><br><span class="line"><span class="number">654321</span></span><br><span class="line"><span class="number">54321</span></span><br><span class="line"><span class="number">654321</span></span><br><span class="line"><span class="number">654321</span>asd</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>类与对象</title>
    <url>/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h4 id="类与对象关系、属性、方法与对象"><a href="#类与对象关系、属性、方法与对象" class="headerlink" title="类与对象关系、属性、方法与对象"></a>类与对象关系、属性、方法与对象</h4><p>类通常是一类事物的抽象，某个具体类的实例为对象，如 人为一个类，则你、我、他是这个类的具体实例，也就是对象。Java是面向对象的语言，每个对象都有自己的属性和方法，属性描述了类的特点，方法描述了类的功能。如肤色、身高是人的属性，吃喝玩是类的功能。</p>
<a id="more"></a>

<h4 id="封装、继承、多态"><a href="#封装、继承、多态" class="headerlink" title="封装、继承、多态"></a>封装、继承、多态</h4><p><code>封装：将抽象性函式接口的实现细节部分包装，隐藏起来，防止类的代码和数据被外部类定义的代码随机访问。可以通过接口暴露代码或数据。重要的功能是能修改自己实现的代码，而不用修改调用此代码的程序片段。</code></p>
<p><code>继承：继承就是子类继承父类的特征和行为。子类通过extend或implements声明继承父类，子类能继承父类非private的属性和方法，子类可以拥有自己的属性和方法。extend单一继承一个子类只能有一个父类。implements多继承一个子类可以有多个父类，父类的类型为interface。在类中super指向父类的引用，this指向本类的引用。</code></p>
<p><code>多态：方法的重载,参数多态,一个类中的多个方法，方法名相同，参数列表不同/个数不同/返回值不同。方法的重写覆盖,对于父类中的某个方法,在子类重新定义一个相同形态的方法。即多态的实现为重写或接口</code></p>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><ul>
<li>抽象类用abstract声明。</li>
<li>抽象类不能被实例化、其他特性与普通类相同，如属性，方法等。</li>
<li>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
<li>抽象类中可以有不抽象的方法，但包含抽象方法的类一定是抽象类。</li>
<li>任何类继承抽象类必须实现抽象方法，或者声明自身为抽象类。</li>
<li>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</li>
<li>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</li>
</ul>
<p><code>抽象类实例如下</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h4><ul>
<li>在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</li>
<li>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</li>
<li>类描述对象的属性和方法。接口则包含类要实现的方法。</li>
<li>接口没有构造方法。</li>
<li>接口中所有的方法必须是抽象方法。</li>
<li>接口不能包含成员变量，除了 static 和 final 变量。</li>
<li>接口不是被类继承了，而是要被类实现。</li>
<li>接口支持多继承。</li>
<li>接口不能用于实例化对象。</li>
<li>接口中的方法会被隐式的指定为 <strong>public abstract</strong>（只能是 public abstract，其他修饰符都会报错）。</li>
<li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 <strong>public static final</strong> 变量（并且只能是 public，用 private 修饰会报编译错误）。</li>
<li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</li>
<li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li>
<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <strong>public static final</strong> 类型的。</li>
<li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
<li>接口是隐式抽象的，当声明一个接口的时候，不必使用<strong>abstract</strong>关键字。</li>
<li>接口中每一个方法也是隐式抽象的，声明时同样不需要<strong>abstract</strong>关键字。</li>
<li>接口中的方法都是公有的。（public）</li>
</ul>
<p><code>接口类实例，以及抽象类继承接口类</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">interface</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String FORWHO = <span class="string">&quot;animal&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> alive  = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span>  <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">think</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Action.FORWHO);</span><br><span class="line">        System.out.println(<span class="string">&quot;animals can walk&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类的创建及初始化"><a href="#类的创建及初始化" class="headerlink" title="类的创建及初始化"></a>类的创建及初始化</h4><p><code>在面向对象的思想中，一切物体皆对象，我们以对象为单位进行编程，将这个对象所有的属性方法包装在一起，就是封装。一般情况，我们通过类的构造器来创建类对象，构造器是一个拥有和类名同样的名字的方法，我们可以对它传递参数，进行一些初始化工作。</code></p>
<p><code>当类中没有显式的声明构造方法时，编译器会自动生成空参数的构造方法，如下列代码,程序执行后输出10说明person对象创建成功</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	String name = <span class="string">&quot;10&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    System.out.println(person.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>但是当我们手动添加一个带有参数的构造函数，如下面第一段代码，编译时会报错，因为在java中如果我们声明了带参数的构造函数后，如果想使用不带参数的构造函数则必须将无参构造函数显式的声明出来。</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *错误</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name = <span class="string">&quot;10&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(person.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *正确</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name = <span class="string">&quot;10&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(person.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类属性方法的初始化顺序"><a href="#类属性方法的初始化顺序" class="headerlink" title="类属性方法的初始化顺序"></a>类属性方法的初始化顺序</h4><p><code>观察下列代码</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;this is static in Person&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(int id) &#123;</span><br><span class="line">        System.out.println(&quot;person(&quot; + id + &quot;)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Build b &#x3D; new Build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Build&#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;this is static in Build&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Person p1 &#x3D; new Person(1);</span><br><span class="line"></span><br><span class="line">    public Build() &#123;</span><br><span class="line">        System.out.println(&quot;this is build&#39;s block!&quot;);</span><br><span class="line">        Person p2 &#x3D; new Person(2);</span><br><span class="line">    &#125;</span><br><span class="line">    Person p3 &#x3D; new Person(3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>此段代码运行后输出结果为</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this is static in Person</span><br><span class="line">this is static in Build</span><br><span class="line">person(1)</span><br><span class="line">person(3)</span><br><span class="line">this is build&#39;s block!</span><br><span class="line">person(2)</span><br></pre></td></tr></table></figure>

<p><code>此段代码的运行结果说明，在一个类的初始化过程中，静态代码块里的程序最先执行，之后为属性的初始化，并且无论属性所处位置如何，属性的初始化顺序大于方法的初始化顺序，包括构造方法。</code></p>
<p><code>现在我们改一下上述代码观察一下静态代码块与非静态代码块</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is non-static&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is static in Person&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;person(&quot;</span> + id + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="number">1</span>);</span><br><span class="line">        Person person1 = <span class="keyword">new</span> Person(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>此程序运行后，输出结果为：</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this is static in Person</span><br><span class="line">this is non-static</span><br><span class="line">person(1)</span><br><span class="line">this is non-static</span><br><span class="line">person(2)</span><br></pre></td></tr></table></figure>

<p><code>我们发现，在两次初始化过程中，非静态代码块执行了两次，而静态代码块执行了一次，并且执行顺序在非静态代码块前。这说明，在类的初始化过程中，静态代码块在程序声明周期中最多运行一次。静态代码块是在类的装载时期（加入.class文件时）运行的，而非静态代码块在构造方法之前运行</code></p>
<p><code>对于静态块和静态属性，执行顺序在与其在代码中的顺序，非静态块和属性同上</code></p>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p><code>被static修饰的变量或方法都属于类变量、类方法，属于类的属性信息（在方法去分配内存），如静态块一样，其它的静态数据也具有这个特点：初始化只在类装载的时候执行一次。对于类变量和类方法，还有一个重要的特点就是，外部对象对他们的引用可以直接通过类名来调用，如上述抽象类中打印接口Action的FORWHO</code></p>
<h4 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h4><p><code>protected的权限控制在包内</code></p>
<h4 id="java-不定参数调用"><a href="#java-不定参数调用" class="headerlink" title="java 不定参数调用"></a>java 不定参数调用</h4><p><code>观察下列代码</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String ... value)</span></span>&#123;</span><br><span class="line">        System.out.println(value[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;length:&quot;</span> +value.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(person.test(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;bc&quot;</span>,<span class="string">&quot;d&quot;</span>));</span><br><span class="line">        System.out.println(person.test(<span class="string">&quot;123124&quot;</span>,<span class="string">&quot;345234&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>程序输出结果为</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">length:3</span><br><span class="line">123124</span><br><span class="line">length:2</span><br></pre></td></tr></table></figure>

<p><code>可以看出，参数是数组</code></p>
<h4 id="内部类创建"><a href="#内部类创建" class="headerlink" title="内部类创建"></a>内部类创建</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;a is print&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;b is print&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        InnerClass ic = <span class="keyword">new</span> InnerClass();</span><br><span class="line">        A  a = ic.<span class="function">new <span class="title">A</span><span class="params">()</span></span>;</span><br><span class="line">        InnerClass.B  b = <span class="keyword">new</span> B();</span><br><span class="line">        a.a();</span><br><span class="line">        b.b();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>java支持中文的类名方法名如下列代码</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 学生</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> 说()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="循环中止"><a href="#循环中止" class="headerlink" title="循环中止"></a>循环中止</h4><p><code>break:中止循环</code></p>
<p><code>continue:跳出当前循环进行下一循环</code></p>
<p><code>多层循环跳出时定义一个label，在需要跳出的地方使用 break label即可，如下列代码</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BreakUse &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        loop:for (int i &#x3D; 0;i &lt; 10;i++)&#123;</span><br><span class="line">            for(int j &#x3D; 10;j &gt; 0;j--)&#123;</span><br><span class="line">                if(i &gt;5 &amp;&amp; j&lt;9)&#123;</span><br><span class="line">                    System.out.println(&quot;i:&quot;+i+&quot;,j:&quot;+j);</span><br><span class="line">                    break loop;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>输出结果为</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i:6,j:8</span><br></pre></td></tr></table></figure>



<h4 id="继承时父类子类的构造器"><a href="#继承时父类子类的构造器" class="headerlink" title="继承时父类子类的构造器"></a>继承时父类子类的构造器</h4><p><code>在对子类进行初始化时，先调用父类的构造函数，如下列代码</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExtends</span> <span class="keyword">extends</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestExtends</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testExtends&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> TestExtends();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>输出结果为</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test</span><br><span class="line">testExtends</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>集合类</title>
    <url>/%E9%9B%86%E5%90%88%E7%B1%BB/</url>
    <content><![CDATA[<h3 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h3><h4 id="常见的集合类："><a href="#常见的集合类：" class="headerlink" title="常见的集合类："></a>常见的集合类：</h4><ul>
<li><p>实现Collection接口的</p>
<p>Set List 以及他们的实现类</p>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>实现Map接口的</p>
<p>HashMap及其实现类</p>
</li>
</ul>
<ul>
<li><p>常用的</p>
<p>HashMap、HashTable、List、Set、ArrayList、HashSet</p>
</li>
</ul>
<h4 id="关系图表"><a href="#关系图表" class="headerlink" title="关系图表"></a>关系图表</h4><p><img src="/images/%E9%9B%86%E5%90%88%E7%B1%BB.jpg" alt="集合类"></p>
<p><img src="/images/%E9%9B%86%E5%90%88%E7%B1%BB%EF%BC%88Map%EF%BC%89.jpg" alt="集合类（Map）"></p>
<h4 id="Set-List-Map-区别联系"><a href="#Set-List-Map-区别联系" class="headerlink" title="Set List Map 区别联系"></a>Set List Map 区别联系</h4><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><ul>
<li><p>成员不能重复</p>
</li>
<li><p>实现类：HashSet、TreeSet、LinkedHashSet</p>
</li>
<li><p>HashSet</p>
<p> 操作：外部无序的遍历成员</p>
<p>成员要求：成员可为任意的Object子类的对象，但如果覆盖了equals方法，同时注意要修改hashCode方法</p>
</li>
</ul>
<ul>
<li><p>TreeSet</p>
<p>操作：外部有序的遍历成员，附加实现了SortedSet，支持子集等要求顺序的操作</p>
<p>成员要求：成员要求实现caparable接口，或者使用 Comparator构造TreeSet，成员一般为同一类型</p>
</li>
</ul>
<ul>
<li><p>LinkedHashSet</p>
<p>操作：外部按成员的插入顺序遍历成员</p>
<p>成员要求：成员与HashSet成员类似</p>
</li>
</ul>
<h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><ul>
<li><p>提供基于索引的队列成员的随机访问</p>
</li>
<li><p>实现类：ArrayList、LinkedList等</p>
</li>
<li><p>ArrayList</p>
<p>操作：提供快速的==基于索引==的成员访问，对尾部成员的增加和删除支持较好</p>
<p>成员要求：成员可为任意Object子类对象</p>
</li>
</ul>
<ul>
<li><p>LinkedList</p>
<p>操作：对列表中任何位置的成员的增加和删除支持较好，但对于基于索引的成员访问支持性能较差</p>
<p>成员要求：成员可为任意Object子类的对象</p>
</li>
</ul>
<h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><ul>
<li><p>保存键值对成员，基于键找值操作，compareTo或compare方法对键排序</p>
</li>
<li><p>实现类：HashMap、TreeMap、LinkedHashMap、IdentityHashMap、WeakHashMap</p>
</li>
<li><p>HashMap</p>
<p>操作：能满足用户对Map的通用需求</p>
<p>成员要求：键成员可为任意Object子类的对象，但如果覆盖了equals方法，同时注意修改hashCode方法</p>
</li>
</ul>
<ul>
<li><p>TreeMap</p>
<p>操作：支持对键有序的遍历，使用时建议先用HashMap增加和删除成员，最后从HashMap生成TreeMap;附加实现了SortedMap接口，支持子Map等要求顺序的操作</p>
<p>成员要求：键成员要求实现caparable接口或者使用comparator构造TreeMap，键成员一般为同一类型</p>
</li>
</ul>
<ul>
<li><p>LinkedHashMap</p>
<p>操作：<u>保留键的插入顺序</u>，用equals方法检查键和值得相等性</p>
<p>成员要求：成员可为任意Object子类的对象，但如果覆盖了equals方法，同时注意修改hashCode方法</p>
</li>
</ul>
<ul>
<li><p>IdentityHashMap</p>
<p>操作：使用==来检查键和值的相等性</p>
<p>成员要求：成员使用的是严格相等</p>
</li>
</ul>
<ul>
<li><p>WeakHashMap</p>
<p>操作：其行为依赖于垃圾回收线程，没有理由则少用</p>
</li>
</ul>
<h5 id="总观"><a href="#总观" class="headerlink" title="总观"></a>总观</h5><p>实现Collection接口的类，如Set和List，他们都是单值元素（其实Set内部也是采用Map来实现的，只是==键值一样==，从表面理解，就是单值），不像实现Map接口的类一样，里面存放的是key-value（键值对）形式的数据。这方面就会造成他们很多的不同点，如遍历方式，前者只能采用迭代或者循环来取值，但是后者可以使用键来获得键的值</p>
<p>Set接口不保证维护元素的顺序，而且元素不能重复。List接口维护元素的顺序，而且元素可以重复。</p>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><ul>
<li><p>Map 是Key-Value对映射的抽象接口。改映射不包括重复的键，即一个键对应一个值。简单地说，HashMap是基于哈希表的Map接口的实现，以Key-Value的形式存在，即存储的对象是==Entry==(To那个是包含了Key和Value)。</p>
</li>
<li><p>非线程安全，即任一时刻，可以有==多个线程同时写HashMap==,如需满足线程安全可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p>
</li>
<li><p>在HashMap中，其会根据==hash算法来计算key-value的存储位置==，并进行快速存取。</p>
</li>
<li><p>HashMap最多只允许一条Entry的键为Nul,但允许多条entry的值为Null即key最多只有一个为null而value没有限制</p>
</li>
<li><p>HashMap是Map的一个==非同步==的实现</p>
</li>
<li><p>HashMap与HashSet虽然实现的接口规范不同，但是他们底层的Hash存贮机制完全相同，实际上，HashSet本身就是在HashMap的基础上实现的。</p>
</li>
<li><p>虽然容器号称存贮的是Java对象，但实际上并不会真正将Java对象放入容器中，只是在容器中保留这些对象的引用。也就是说Java容器实际上包含的是==引用变量==，而这些引用变量指向了我们要实际保存的java对象。</p>
</li>
<li><p>JDK1.8引入==红黑树==大程度优化了HashMap的性能。</p>
<h4 id="HashMap-源码中的分析"><a href="#HashMap-源码中的分析" class="headerlink" title="HashMap 源码中的分析"></a>HashMap 源码中的分析</h4><p><code>哈希的相关概念：Hash就是把任意长度的输入（又叫预映射，pre-image），通过哈希算法，变换成固定长度的输出（通常是整型），该输出就是哈希值。这种转换是一种压缩映射,也就是说散列值的空间通常小于输入的空间。不同的输入可能会散列成相同的输出，从而不可能从散列值来唯一的确定输入值。简单的说，就是将任意长度的消息压缩到某一一固定长度的摘要函数</code></p>
<p><code>loadFactor:负载因子，用于衡量的是一个散列表的空间的使用程度</code></p>
<p><code>threshold:HashMap进行扩容的阈值，他的值等于HashMap的容量乘以负载因子</code></p>
<p><code>table:说明HashMap的底层实现仍是数组，只是数组的每一项都是一条链</code></p>
<p><code>初始容量和负载因子：这两个参数是影响HashMap性能的重要参数。其中容量拜师哈希表中桶的数量（table数组的大小）初始容量是创建哈希表时痛的数量；负载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，他衡量的是一个散列表的使用程度，负载因子越大表示散列表的装填程度越高，反之越小</code></p>
<p><code>HashMap的底层实现还是数组，只是数组的每一项都是一条链</code></p>
</li>
</ul>
<p>  <img src="https://img-blog.csdn.net/20170317181650025?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty HashMap with the default initial capacity</span></span><br><span class="line"><span class="comment">     * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//负载因子:用于衡量的是一个散列表的空间的使用程度</span></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line"></span><br><span class="line">        <span class="comment">//HashMap进行扩容的阈值，它的值等于 HashMap 的容量乘以负载因子</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// HashMap的底层实现仍是数组，只是数组的每一项都是一条链DEFAULT_INITIAL_CAPACITY是初始长度</span></span><br><span class="line">        table = <span class="keyword">new</span> Entry[DEFAULT_INITIAL_CAPACITY];<span class="comment">//table</span></span><br><span class="line"></span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>Entry（Node 1.8继承自Map.Entry）为HashMap的内部类，实现了Map.Entry接口，其包含了键Key、值value、下一个节点next、以及hash值四个属性。事实上，Entry是构成hash table的基石，是哈希表所存储的元素的具体形式</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> K key;     <span class="comment">// 键值对的键</span></span><br><span class="line">    V value;        <span class="comment">// 键值对的值</span></span><br><span class="line">    Entry&lt;K,V&gt; next;    <span class="comment">// 下一个节点</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;     <span class="comment">// hash(key.hashCode())方法的返回值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates new entry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;     <span class="comment">// Entry 的构造函数</span></span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java 1.8</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></span><br><span class="line"> </span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="HashMap快速存储"><a href="#HashMap快速存储" class="headerlink" title="HashMap快速存储"></a>HashMap快速存储</h5><p><code>HashMap中，最常用的操作就是put和get，在HashMap中key是惟一的。他保持唯一性首先不是通过equals方法进行比较，因为这种方法的时间复杂度是O(n)达不到HashMap快速存取的目的。实际上当我们put时，HashMap首先会调用Key的hashCode方法，然后基于此获取Key哈希码，通过哈希码快速找到某个桶即table数组中的位置，这个位置被称之为bucketIndex，如果两个对象的hashCode不同，那么equals一定为false。但是当其hashCode相同时，equals不一定为true。当这种情况发生时，我们称之为碰撞。碰撞发生后，会去除bucketIndex桶内已存储的元素，并通过hashCode()和equals方法来比较判断key是否已存在，如果存在则新的value替换旧的，不存在则存放新的键值对到桶中，所以equals方法只有在哈希码碰撞时才会用到。</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment"> * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment"> * value is replaced.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with key, or null if there was no mapping for key.</span></span><br><span class="line"><span class="comment"> *  Note that a null return can also indicate that the map previously associated null with key.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当key为null时，调用putForNullKey方法，并将该键值对保存到table的第一个位置 </span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据key的hashCode计算hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());             <span class="comment">//  ------- (1)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算该键值对在数组中的存储位置（哪个桶）</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);              <span class="comment">// ------- (2)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//在table的第i个桶上进行迭代，寻找 key 保存的位置</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;      <span class="comment">// ------- (3)</span></span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">//判断该条链上是否存在hash值相同且key值相等的映射，若存在，则直接覆盖 value，并返回旧value</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;    <span class="comment">// 返回旧值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++; <span class="comment">//修改次数增加1，快速失败机制</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//原HashMap中无该映射，将该添加至该链的链头</span></span><br><span class="line">    addEntry(hash, key, value, i);            </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="HashMap扩容机制"><a href="#HashMap扩容机制" class="headerlink" title="HashMap扩容机制"></a>HashMap扩容机制</h5><p><code>结合负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。</code></p>
<p><code>Java中的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   <span class="comment">//传入新的容量</span></span><br><span class="line">    Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;         </span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">        threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">    transfer(newTable);                         <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line">    table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);<span class="comment">//修改阈值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="HashMap的底层数组长度总是2的n次方的原因"><a href="#HashMap的底层数组长度总是2的n次方的原因" class="headerlink" title="HashMap的底层数组长度总是2的n次方的原因"></a>HashMap的底层数组长度总是2的n次方的原因</h5><p><code>我们知道，HashMap的底层数组长度总是2的n次方，原因是 HashMap 在其构造函数 HashMap(int initialCapacity, float loadFactor) 中作了特别的处理，如下面的代码所示。当底层数组的length为2的n次方时， h&amp;(length - 1) 就相当于对length取模，其效率要比直接取模高得多，这是HashMap在效率上的一个优化</code></p>
<ul>
<li><strong>不同的hash值发生碰撞的概率比较小，这样就会使得数据在table数组中分布较均匀，空间利用率较高，查询速度也较快；</strong></li>
<li><strong>h&amp;(length - 1) 就相当于对length取模，而且在速度、效率上比直接取模要快得多，即二者是等价不等效的，这是HashMap在速度和效率上的一个优化。</strong></li>
</ul>
<p>由于是双倍扩容，迁移过程中，会将原来 table[i] 中的链表的所有节点，分拆到新的数组的 newTable[i] 和 newTable[i + oldLength] 位置上。如原来数组长度是 16，那么扩容后，原来 table[0] 处的链表中的所有元素会被分配到新数组中 newTable[0] 和 newTable[16] 这两个位置。</p>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><ul>
<li>LinkedList 底层采用双向循环列表实现，进行插入和删除操作时具有较高的速度，可以使用LinkedList来实现队列和栈。但是在随机访问方面效率不高</li>
<li>LinkedList 继承了AbstractSequentialList接口，AbstractSequentialList相比于AbstractList只支持次序访问1而不支持随机访问，因为前者的get(int index),set(int index,E element),add(int index,E element),remove(int index)都是基于迭代器实现的，所以在LinkedList使用迭代器遍历更快，而ArrayList使用get(i)更快。</li>
</ul>
<h5 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h5><p><code>transient int size = 0;//计数 链表中的节点个数</code></p>
<p><code>transient Node&lt;E&gt; first;// 头节点指针</code></p>
<p><code>transient Node&lt;E&gt; last;// 尾节点指针</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">  E item;</span><br><span class="line">  Node&lt;E&gt; next;</span><br><span class="line">  Node&lt;E&gt; prev;</span><br><span class="line">  Node(Node&lt;E&gt; prev,E element,Node&lt;E&gt; next)&#123;</span><br><span class="line">    <span class="keyword">this</span>.item = element;<span class="comment">//当前节点值</span></span><br><span class="line">    <span class="keyword">this</span>.next = next;<span class="comment">//后继节点</span></span><br><span class="line">    <span class="keyword">this</span>.prev = prev;<span class="comment">//前驱节点</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="插入与删除"><a href="#插入与删除" class="headerlink" title="插入与删除"></a>插入与删除</h5><ul>
<li><p>获取节点</p>
<p>getFirst()、getList()、get(int index);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *检查非空后，直接返回first节点的item</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">  <span class="keyword">if</span>(f==<span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">  <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *检查非空后，直接返回last节点的item</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">  <span class="keyword">if</span>(l == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">  <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;<span class="comment">//indexOf LastIndexof同理</span></span><br><span class="line">  checkElementIndex(index);<span class="comment">//checkElemetIndex中主要用到isElementIndex方法</span></span><br><span class="line">  <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;<span class="comment">//事实证明确实是迭代取值</span></span><br><span class="line">  <span class="keyword">if</span>(index &lt;(size&gt;&gt;<span class="number">1</span>))&#123;<span class="comment">//判断index是在链表偏左侧还是偏右侧</span></span><br><span class="line">    Node&lt;E&gt; x = first;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;index;i++)</span><br><span class="line">      x = x.next;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    Node&lt;E&gt; x = last;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = size-<span class="number">1</span>;i&gt;index;i--)</span><br><span class="line">      x = x.prev;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置节点</p>
<p>set(int index),add(int index,E element),addFirst(E e),addLast(E e);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index,E element)</span></span>&#123;</span><br><span class="line">  checkElemetIndex(index);</span><br><span class="line">  Node&lt;E&gt; x = node(index);</span><br><span class="line">  E oldVal = x.item;</span><br><span class="line">  x.item = element;<span class="comment">//根据node返回的对象直接赋值就能更改，我认为是node函数返回的就是那个对象，而x是引用，索引当用x.item进行赋值时实际上将堆内存中的内容改变。</span></span><br><span class="line">  <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,E element)</span></span>&#123;<span class="comment">//实际就是在指定前插入一个新的节点，并将旧的节点的prev设置为这个新的节点，旧的节点前的节点的next指向新的节点。</span></span><br><span class="line">  checkPositionIndex(index);</span><br><span class="line">  <span class="keyword">if</span> (index == size)</span><br><span class="line">    linkLast(element);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//addFirst、addList很简单不做赘述</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="与ArrayList"><a href="#与ArrayList" class="headerlink" title="与ArrayList"></a>与ArrayList</h5><p>相同点：都实现了Collection接口</p>
<p>不同点：ArrayList基于数组，具有较高的查询速度，而LinkedList基于双向循环链表，具有较快的添加或者删除的速度，</p>
<h4 id="两两对比"><a href="#两两对比" class="headerlink" title="两两对比"></a>两两对比</h4><h5 id="HashMap和HashTable"><a href="#HashMap和HashTable" class="headerlink" title="HashMap和HashTable"></a><strong>HashMap和HashTable</strong></h5><p>相同点：两者都实现了Map接口，因此具有一系列Map接口提供的发法</p>
<p>不同点：</p>
<p>HashMap继承了AbstractMap，而HashTable继承了Dictionary。</p>
<p> HashMap非线程安全，HashTable线程安全，到处都是synchronized关键字。</p>
<p>因为HashMap没有同步，所以处理起来效率较高。</p>
<p>HashMap键、值都允许为null，HashTable键、值都不允许有null。</p>
<p>HashTable使用Enumeration，HashMap使用Iterator。</p>
<h5 id="Set-和List"><a href="#Set-和List" class="headerlink" title="Set 和List"></a>Set 和List</h5><p>相同点：都实现了Collection接口</p>
<p>不同点：</p>
<p>Set接口不保证维护元素的顺序，并且元素不能重复。List维护元素第二顺序，元素可以重复</p>
<h5 id="SortedSet-和SortedMap"><a href="#SortedSet-和SortedMap" class="headerlink" title="SortedSet 和SortedMap"></a>SortedSet 和SortedMap</h5><p>两者都提供了排序的功能</p>
<h5 id="TreeMap和HashMap"><a href="#TreeMap和HashMap" class="headerlink" title="TreeMap和HashMap"></a>TreeMap和HashMap</h5><p>HashMap具有较高的速度（查询）,TreeMap则提供了按照键进行排序的功能。</p>
<h5 id="HashSet和LinkedHashSet"><a href="#HashSet和LinkedHashSet" class="headerlink" title="HashSet和LinkedHashSet"></a>HashSet和LinkedHashSet</h5><p>HashSet,为快速查找而设计的set，存入HashSet的对象必须实现hashCode和equals</p>
<p>LinkedHashSet，具有HashSet的查询速度，且内部使用链表维护元素的顺序（插入的顺序），于是在使用迭代器遍历Set时，结果会按照元素插入的次序显示</p>
<h5 id="TreeSet和HashSet"><a href="#TreeSet和HashSet" class="headerlink" title="TreeSet和HashSet"></a>TreeSet和HashSet</h5><p>TreeSet提供排序功能的Set，底层为树结构，相比较HashMap查询速度滴，如果只是元素的查询，我们一般使用HashSet</p>
<h5 id="ArrayList和Vector"><a href="#ArrayList和Vector" class="headerlink" title="ArrayList和Vector"></a>ArrayList和Vector</h5><p>同步性：Vector是线程安全的，也就是说同步的，而ArrayList是线程不安全的，不是同步的。</p>
<p>数据增长：当需要增长时，Vector默认增长为原来的一倍，而ArrayList确实原来的一半</p>
<h5 id="Collection和Collections"><a href="#Collection和Collections" class="headerlink" title="Collection和Collections"></a>Collection和Collections</h5><p>Collection是一些列单值集合类的负借口，提供了基本的一些方法，而Collections则是一系列算法的集合。里面的属性和方法基本都是static的，也就是不需要实例化，直接可以使用类名来调用。</p>
<p>collections可以生成单元素集合（</p>
<p>Collections中的单元素集合指的是集合中只有一个元素而且集合只读。<br>Collections.singletonList——用来生成只读的单一元素的List<br>Collections.singletonMap——用来生成只读的单Key和Value组成的Map</p>
<p>Collections.singleton——用来生成只读的单一元素的Set</p>
<p>）</p>
<p>Checked集合、同步集合（为一些非线程安全的集合类提供同步机制）查找替换、集合排序</p>
]]></content>
  </entry>
</search>
