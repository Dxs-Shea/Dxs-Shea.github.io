<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Leetcode 110. 平衡二叉树</title>
    <url>/Leetcode110.%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="Leetcode110-平衡二叉树"><a href="#Leetcode110-平衡二叉树" class="headerlink" title="Leetcode110. 平衡二叉树"></a>Leetcode110. 平衡二叉树</h1><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p>
<a id="more"></a>


<p>示例:</p>
<p><strong>示例 1:</strong></p>
<p>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回 true 。</p>
<p>示例 2:</p>
<p>给定二叉树 [1,2,2,3,3,null,null,4,4]</p>
<pre><code>   1
  / \
 2   2
/ \</code></pre>
<p>   3   3<br>  / <br> 4   4<br>返回 false 。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/balanced-binary-tree">https://leetcode-cn.com/problems/balanced-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><ul>
<li>求出树的高度，看左右子树相差的高度是否超过 1</li>
<li><strong>自底向上</strong></li>
<li><strong>复杂度分析：</strong><ul>
<li><strong>时间复杂度O(N)：</strong></li>
</ul>
</li>
</ul>
<h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BalancedBinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不要设为static变量</span></span><br><span class="line">    <span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = helper(root.left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = helper(root.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(right - left) &gt; <span class="number">1</span>) res = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//此处在right递归求解时候，求最大高度，用最大高度完成上面的绝对值的求解</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="一点点收获"><a href="#一点点收获" class="headerlink" title="一点点收获"></a>一点点收获</h3><ul>
<li><p>static变量</p>
</li>
<li><p>递归</p>
</li>
<li><p>本地输入输出-树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">le</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">createTree</span><span class="params">(String tree)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// &#123;1,2,3,4,#,#,#,5,#,6,#,7,#,8&#125;</span></span><br><span class="line">        String[] ss = tree.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> createTree(ss);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">createTree</span><span class="params">(String[] tree)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="comment">// 1st one should not be #</span></span><br><span class="line">        TreeNode root = constructOne(tree[<span class="number">0</span>]);</span><br><span class="line">        q.add(root);</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            TreeNode tn = q.poll();</span><br><span class="line">            <span class="keyword">if</span> (tn == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// construct tn&#x27;s left&amp;right node</span></span><br><span class="line">            <span class="comment">// when to stop</span></span><br><span class="line">            <span class="keyword">if</span> (idx == tree.length) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode left_ = constructOne(tree[idx]);</span><br><span class="line">            tn.left = left_;</span><br><span class="line">            q.add(left_);</span><br><span class="line">            idx++;</span><br><span class="line">            <span class="keyword">if</span> (idx == tree.length) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode right_ = constructOne(tree[idx]);</span><br><span class="line">            idx++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            tn.right = right_;</span><br><span class="line">            <span class="comment">// add to queue</span></span><br><span class="line">            q.add(right_);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TreeNode <span class="title">constructOne</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.compareTo(<span class="string">&quot;null&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(Integer.parseInt(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode tn = createTree(<span class="string">&quot;3,9,20,null,null,15,7&quot;</span>);</span><br><span class="line">        BalancedBinaryTree balancedBinaryTree = <span class="keyword">new</span> BalancedBinaryTree();</span><br><span class="line">        <span class="keyword">int</span> i=balancedBinaryTree.helper(tn);</span><br><span class="line">        System.out.println(balancedBinaryTree.res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BalancedBinaryTree</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            helper(root);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> left = helper(root.left) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = helper(root.right) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(right - left) &gt; <span class="number">1</span>) res = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> Math.max(left, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 155. 最小栈</title>
    <url>/Leetcode155.%20%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    <content><![CDATA[<p>Leetcode 155. 最小栈</p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>push(x) —— 将元素 x 推入栈中。<br>pop() —— 删除栈顶的元素。<br>top() —— 获取栈顶元素。<br>getMin() —— 检索栈中的最小元素。</p>
<a id="more"></a>


<p>示例:</p>
<p>输入：<br>[“MinStack”,”push”,”push”,”push”,”getMin”,”pop”,”top”,”getMin”]<br>[[],[-2],[0],[-3],[],[],[],[]]</p>
<p>输出：<br>[null,null,null,null,-3,null,0,-2]</p>
<p>解释：<br>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2.</p>
<p>提示：pop、top 和 getMin 操作总是在 非空栈 上调用。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/min-stack">https://leetcode-cn.com/problems/min-stack</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><ul>
<li><p>使用辅助栈min_stack，获取stack的最小值</p>
</li>
<li><p><strong>算法流程</strong></p>
<ul>
<li>push()方法：</li>
<li>pop()方法：</li>
<li>getMin()方法：</li>
</ul>
</li>
<li><p><strong>min_stack作用分析：</strong></p>
<ul>
<li>栈顶元素获取最小值</li>
<li>保证栈顶元素是stack中最小的元素</li>
</ul>
</li>
<li><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度O(1)：</strong>压栈、出栈、获取最小值的时间复杂度都为O(1)</li>
<li><strong>空间复杂度O(N)：</strong>包含N个元素的辅助栈占用线性大小的额外空间</li>
</ul>
</li>
</ul>
<h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; min_stack;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        min_Stack=<span class="keyword">new</span> min_Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//stack=stack.push(x);</span></span><br><span class="line">        stack.push(x);</span><br><span class="line">        <span class="keyword">if</span>(min_stack.isEmpty()||x&lt;min_stack.peek()) min_stack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//stack.pop();</span></span><br><span class="line">        <span class="keyword">if</span>(stack.pop().equals(min_stack.peek())) min_stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//stack.top();</span></span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> min_stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>





<h3 id="一点点收获"><a href="#一点点收获" class="headerlink" title="一点点收获"></a>一点点收获</h3><p>栈：LIFO 后进先出模型【栈顶指针随之移动】</p>
<p><img src="/Leetcode155/image-20201011181640126.png" alt="image-20201011181640126"></p>
<p>可用LinkedList实现栈</p>
<p><img src="/Leetcode155/image-20201011181508145.png" alt="image-20201011181508145"></p>
<p>Stack.Peek 与 stack.pop 的区别</p>
<ul>
<li><p>都返回栈顶的值</p>
</li>
<li><p>stack.peek()：不改变栈的值【不删除栈顶的值】，stack.pop()：会把栈顶值删掉</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis持久化和缓存机制</title>
    <url>/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%92%8C%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>  说到redis，我们可能都会知道了他是一个类似缓存的一个内存数据库，我们从未感知到它的存在是因为他很快，为什么非常快，是因为他的发展到应用很快，还有他的反应速度也是非常快的。</p>
<a id="more"></a>

<h2 id="1-、Redis的适用环境"><a href="#1-、Redis的适用环境" class="headerlink" title="1 、Redis的适用环境"></a>1 、Redis的适用环境</h2><p>首先作为一个nosql的key—value组成的数据库，它们能存储的数据结构必须是简单的，因为有关系的数据即使存储进去之后查询也是很困难的，并且对于海量的数据存储还是关系型数据库比较合适。</p>
<p>举一个把一般数据库数据存储到key-value中的例子：</p>
<table>
<thead>
<tr>
<th>student</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>学号</td>
<td>姓名</td>
<td>年龄</td>
<td>班级</td>
</tr>
<tr>
<td>001</td>
<td>小明</td>
<td>18</td>
<td>2</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>key</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>student:001:姓名</td>
<td>小明</td>
</tr>
<tr>
<td>student:001:年龄</td>
<td>18</td>
</tr>
<tr>
<td>student:001:班级</td>
<td>2</td>
</tr>
</tbody></table>
<p>遵从规则为        key  表名：主键值：列名<br>​                            value  列值</p>
<p>如果加上表关系的话还要复杂好几倍的。</p>
<p>        那么什么样的数据适合存储在非关系型数据库中的呢？</p>
<p>        1、关系不是很密切的的数据，比如用户信息，班级信息，评论数量等等。</p>
<p>        2、量比较大的数据，如访问记录等</p>
<p>​    3、访问比较频繁的数据，如用户信息，访问数量，最新微博等</p>
<h2 id="2、持久化"><a href="#2、持久化" class="headerlink" title="2、持久化"></a>2、持久化</h2><p>那么这么多，这么重要的数据都存储在内存中，如果突然断电，岂不是很糟糕，于是就有了数据的持久化机制，这个其实就是把内存中的数据存储到硬盘中，方便数据的持续存在，也可以减少断电造成的损失。</p>
<p>  那么我们怎么持久化数据呢？多长时间进行一次持久化呢？</p>
<p>redis 支持两种持久化方式，一种是 Snapshotting（快照）也是默认方式，另一种是 Append-only file（缩写 aof）的方式。下面分别介绍：</p>
<h3 id="2-1-Snapshotting"><a href="#2-1-Snapshotting" class="headerlink" title="2.1 Snapshotting"></a>2.1 Snapshotting</h3><p>​      快照是默认的持久化方式。这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。可以通过配置设置自动做快照持久化的方式。我们可以配置 redis在 n 秒内如果超过 m 个 key 被修改就自动做快照，下面是默认的快照保存配置：</p>
<ul>
<li>save 900 1 #900 秒内如果超过 1 个 key 被修改，则发起快照保存</li>
<li>save 300 10 #300 秒内容如超过 10 个 key 被修改，则发起快照保存</li>
<li>save 60 10000</li>
</ul>
<p>下面介绍详细的快照保存过程：</p>
<ol>
<li>redis 调用 fork,现在有了子进程和父进程。</li>
<li>父进程继续处理 client 请求，子进程负责将内存内容写入到临时文件。由于 os 的实时复制机制（ copy on write)父子进程会共享相同的物理页面，当父进程处理写请求时 os 会为父进程要修改的页面创建副本，而不是写共享的页面。所以子进程地址空间内的数据是 fork时刻整个数据库的一个快照。</li>
<li>当子进程将快照写入临时文件完毕后，用临时文件替换原来的快照文件，然后子进程退出。client 也可以使用 save 或者 bgsave 命令通知 redis 做一次快照持久化。 save 操作是在主线程中保存快照的，由于 redis 是用一个主线程来处理所有 client 的请求，这种方式会阻塞所有client 请求。所以不推荐使用。另一点需要注意的是，每次快照持久化都是将内存数据完整写入到磁盘一次，并不是增量的只同步变更数据。如果数据量大的话，而且写操作比较多，必然会引起大量的磁盘 io 操作，可能会严重影响性能。</li>
</ol>
<h3 id="2-2-AOF-方式"><a href="#2-2-AOF-方式" class="headerlink" title="2.2 AOF 方式"></a>2.2 AOF 方式</h3><p>  由于快照方式是在一定间隔时间做一次的，所以如果 redis 意外 down 掉的话，就会丢失最后一次快照后的所有修改。如果应用要求不能丢失任何修改的话，可以采用 aof 持久化方式。</p>
<p>下面介绍 Append-only file:aof 比快照方式有更好的持久化性，是由于在使用 aof 持久化方式时,redis 会将每一个收到的写命令都通过 write 函数追加到文件中(默认是 appendonly.aof)。</p>
<p>当 redis 重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。当然由于 os 会在内核中缓存 write 做的修改，所以可能不是立即写到磁盘上。这样 aof 方式的持久化也还是有可能会丢失部分修改。不过我们可以通过配置文件告诉 redis 我们想要通过 fsync 函数强制 os 写入到磁盘的时机。有三种方式如下（默认是：每秒 fsync 一次）</p>
<ul>
<li>appendonly yes //启用 aof 持久化方式</li>
<li># appendfsync always //收到写命令就立即写入磁盘，最慢，但是保证完全的持久化</li>
<li>appendfsync everysec //每秒钟写入磁盘一次，在性能和持久化方面做了很好的折中</li>
<li># appendfsync no //完全依赖 os，性能最好,持久化没保证</li>
</ul>
<p>aof 的方式也同时带来了另一个问题。持久化文件会变的越来越大。例如我们调用 incr test命令 100 次，文件中必须保存全部的 100 条命令，其实有 99 条都是多余的。因为要恢复数据库的状态其实文件中保存一条 set test 100 就够了。为了压缩 aof 的持久化文件。 redis 提供了 bgrewriteaof 命令。收到此命令 redis 将使用与快照类似的方式将内存中的数据以命令的方式保存到临时文件中，最后替换原来的文件。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Se7en</title>
    <url>/Se7en/</url>
    <content><![CDATA[<p><img src="/.com//seven.jpg" alt="seven"></p>
<p>​        最近不在状态，今天下午看个电影，试图找回状态，遂选择了之前没有看完的《七宗罪》😈</p>
<p>​        转载链接：<a href="https://www.zhihu.com/question/30624448/answer/232930196">https://www.zhihu.com/question/30624448/answer/232930196</a></p>
<a id="more"></a>

<p>​        《七宗罪》由摩根弗里曼和布拉德皮特主演，涉及到了宗教中的七原罪、<strong>精神疾病、悬疑、社会现象、人性隐喻、个人成长</strong>等多个方面，每一个方面拿出来，都是可以作为完整的一篇电影解析来呈现的。</p>
<p>​        此文在社会现象和电影结构两点展开</p>
<p>​        在影片的开头里，我们也看到了萨摩赛特办一场<strong>杀夫案</strong>的时候，问警员：<strong>孩子看到了吗</strong>？警员埋怨萨摩赛特多管闲事，让他管好自己和工作就好了，不要为自己找麻烦。</p>
<p><img src="/.com//image-20201011192148995.png" alt="image-20201011192148995"></p>
<p>​        在影片里，萨摩赛特提到了自己遇见的一件事情加以佐证这种想法，他说自己并不是悲观，而是人性确实如此，一个女人收到迫害的时候，**喊“救火”甚至比“救命”要有效…**影片中多次通过萨摩赛特的对话让我们了解了他本人的一些观念，而从这些观念中，我们得出，萨摩赛特与现代生活是格格不入的。</p>
<p>​        他会用一台脱离时代的打字机做事情，在一个花花绿绿的世界里独守着“读书”的习惯，对人慈善，遵守着严格的作息和整齐的穿着（在影片开头有展现）…这些，都在说明萨摩赛特的性格和特点。</p>
<p>​        萨摩赛特对现实生活的抵抗，一部分原因来自于对社会现象的失望，而另一个原因则是生活上的格格不入，而<strong>米尔斯</strong>恰巧正式萨摩赛特的对立面。</p>
<p>​        相比于萨摩赛特的沉稳和格格不入，米尔斯的性格冲动而果敢，就连萨摩赛特在评价米尔斯的时候，也提到过他冲动的性格，对于一个DETECTIVE（探员）来说，<strong>最怕的就是冲动的性格</strong>，所以萨摩赛特不止一次提醒他要冷静，但是米尔斯从未听过。</p>
<p><img src="/.com//image-20201011192254140.png" alt="image-20201011192254140"></p>
<p>​        所以你会看到米尔斯打骂了“记者”，因受伤而愤怒的踹门进入了犯人房间，面对萨摩赛特的书单暴躁异常，无法专心等等。</p>
<p>​        无时无刻不在展现了七宗罪中的“愤怒”原罪，萨摩赛特无法去阻止他，就像他不能去阻止凶手一样，事情的进展随着两个人的不断选择而变得越来越诡异。</p>
<p>​        而萨摩赛特也逐渐的发现，自己已经越来越无能为力了。</p>
<h2 id="电影为什么这样叙事？"><a href="#电影为什么这样叙事？" class="headerlink" title="电影为什么这样叙事？"></a>电影为什么这样叙事？</h2><p>​        说完了萨摩赛特，我们再来说一下萨摩赛特的故事线，在上文中我提到了一个概念：环状叙事，我为什么说这是一个环状叙事的故事呢？</p>
<p>​        首先我们先来看看故事的开头，一个非常经典的开头，并且有很多人可能会忽略掉的细节。</p>
<p>​        开头中向我们展现了萨摩赛特遇到的第一个案子，也就是我在前文中所提到的杀父案，警员说是夫妻两人在吵架的时候产生纠纷，因为“<strong>冲动</strong>”而下了杀手，注意这个<strong>冲动</strong>的细节，不是因为钱，也不是因为“出轨”或是其他的原因，只是因为冲动，导致了夫妻之间的杀戮，这是一点，建置了整个故事的引线部分，从这个小案件进而拉出整个连环案件，而这个小案件，就是因为大案件的“原罪”而造成的结果，所以说萨摩赛特接受的第一个案子，其实是整个故事的一个核心，也就是“原罪”。</p>
<p>​        其次，萨摩赛特开头没有关心案件，而是先问“孩子有没有事”，这是一个隐喻（这里并没有过度解读），隐喻米尔斯和其妻子的孩子的事情，而他们的孩子，则是造成米尔斯最后因为冲动杀死约翰杜的<strong>因</strong>。</p>
<p><img src="/.com//v2-b0421221a07bbdca2c7cf989fe9527ab_720w.jpg" alt="img"></p>
<p>​        最终造成了约翰杜因为妒忌而被枪杀的果。</p>
<p>​        <strong>同样的，米尔斯也因为自己的愤怒（冲动）得到了惩罚，愤怒的原罪影响了他的情绪，最终不得不为杀人而承担责任。</strong></p>
<p><img src="/.com//v2-8b0d79cc1957a28071ad181415063c21_720w.jpg" alt="img"></p>
<p>​        由以上看来，<strong>从开头的（冲动）原罪建置，到最后的七原罪的建置圆满，以愤怒（冲动）的原罪作为结局。整个故事呈现出来的，其实就是一个环形结构的形式。</strong></p>
<p>​        导演的心思非常缜密，而且用法也很刁钻，很有意思，从而使得影片最后的升华非常的恰到好处，几乎称得上圆满。</p>
<h2 id="原罪下的布道者与原罪加身者"><a href="#原罪下的布道者与原罪加身者" class="headerlink" title="原罪下的布道者与原罪加身者"></a>原罪下的布道者与原罪加身者</h2><p>​        在影片的最后，约翰杜曾多次指出，自己是在为上帝践行原罪处罚，这一点和萨摩赛特的想法不谋而合了，萨摩赛特既不是布道者，也不是原罪加身者，他厌恶世界的冷漠，但是没有去通过暴力来制止这种冷漠。</p>
<p>​        约翰杜做了萨摩赛特不敢做的事情，他挽救了人们的冷漠，让人们开始对整件事情加以关注，虽然用的方式极其暴力和血腥。</p>
<blockquote>
<p>约翰杜说：我们在每个街角、每个家庭中都看到了原罪…我们容忍了，因为见怪不怪，没什么大不了，我们从早容忍到晚……现在不同了，我立下榜样，世人将对我的所作所为进行思索，和研究，并遵循——直到永远。</p>
</blockquote>
<p>​        这和萨摩赛特的想法其实不谋而合，可以说米尔斯就是萨摩赛特的另一种人格的展现，他们有太多的相似之处。</p>
<p>​        也是从米尔斯身上，萨摩赛特思考到了很多东西。</p>
<p>​        电影中呈现的观点很中性，萨摩赛特没有对约翰杜的所作所为进行一个总结，同样的，他也无法对现实生活中的冷漠进行一个总结。</p>
<blockquote>
<p>就像萨摩赛特在电影最后所引用的海明威的那句话一样：这个世界是个好地方，我们值得为之奋斗。我同意后半句。</p>
</blockquote>
<p>​        萨摩赛特感到了一种无力感，但是他却无法避免这种无力感，正像上文中所提到的，约翰杜的做法是植根于心的，米尔斯也是，他们是性格如此明显的一类人，萨摩赛特无法去改变他们，也无法去改变自己，他老了，终究会辞职，终究会离开世界，而离开世界之前，他想做一些有用的事情。</p>
<p>​        这就是萨摩赛特的想法。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>2020-movies</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql引擎</title>
    <url>/mysql%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h1 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h1><p>常用的存储引擎有以下：</p>
<ul>
<li><p><strong>Innodb引擎</strong>：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。</p>
</li>
<li><p><strong>MyIASM引擎</strong>(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。</p>
</li>
<li><p><strong>MEMORY引擎</strong>：所有的数据都在内存中，数据的处理速度快，但是安全性不高。</p>
<a id="more"></a>

</li>
</ul>
<p><strong>MyISAM与InnoDB区别</strong></p>
<table>
<thead>
<tr>
<th align="center">MyISAM</th>
<th align="center">Innodb</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">存储结构</td>
<td align="center">每张表被存放在三个文件：frm-表格定义、MYD(MYData)-数据文件、MYI(MYIndex)-索引文件</td>
<td align="center">所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB</td>
</tr>
<tr>
<td align="center">存储空间</td>
<td align="center">MyISAM可被压缩，存储空间较小</td>
<td align="center">InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引</td>
</tr>
<tr>
<td align="center">可移植性、备份及恢复</td>
<td align="center">由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作</td>
<td align="center">免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了</td>
</tr>
<tr>
<td align="center">文件格式</td>
<td align="center">数据和索引是分别存储的，数据<code>.MYD</code>，索引<code>.MYI</code></td>
<td align="center">数据和索引是集中存储的，<code>.ibd</code></td>
</tr>
<tr>
<td align="center">记录存储顺序</td>
<td align="center">按记录插入顺序保存</td>
<td align="center">按主键大小有序插入</td>
</tr>
<tr>
<td align="center">外键</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">事务</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">锁支持（锁是避免资源争用的一个机制，MySQL锁对用户几乎是透明的）</td>
<td align="center">表级锁定</td>
<td align="center">行级锁定、表级锁定，锁定力度小并发能力高</td>
</tr>
<tr>
<td align="center">SELECT</td>
<td align="center">MyISAM更优</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">INSERT、UPDATE、DELETE</td>
<td align="center"></td>
<td align="center">InnoDB更优</td>
</tr>
<tr>
<td align="center">select count(*)</td>
<td align="center">myisam更快，因为myisam内部维护了一个计数器，可以直接调取。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">索引的实现方式</td>
<td align="center">B+树索引，myisam 是堆表</td>
<td align="center">B+树索引，Innodb 是索引组织表</td>
</tr>
<tr>
<td align="center">哈希索引</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">全文索引</td>
<td align="center">支持</td>
<td align="center">不支持</td>
</tr>
</tbody></table>
<h3 id="MyISAM索引与InnoDB索引的区别？"><a href="#MyISAM索引与InnoDB索引的区别？" class="headerlink" title="MyISAM索引与InnoDB索引的区别？"></a>MyISAM索引与InnoDB索引的区别？</h3><ul>
<li>InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。</li>
<li>InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。</li>
<li>MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</li>
<li>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</li>
</ul>
<h3 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h3><p>如果没有特别的需求，使用默认的<code>Innodb</code>即可。</p>
<p>MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。</p>
<p>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如OA自动化办公系统。</p>
]]></content>
      <categories>
        <category>学习-2020</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串在java中无非String、StringBuilder、StringBuffer</p>
<p>三者效率比较：StringBuilder &gt; StringBuffer &gt; String,这个比较是相对的，再做大量的对同一字符串进行操作时，这个效率排名一般是正确的，但是当对字符串的操作很少时，比如 String str = “hello” + “world”的效率要高于</p>
<p> StringBuilder str = new StringBuilder().append(“hello”).append(“world”)</p>
<a id="more"></a>

<h4 id="使用选择方式"><a href="#使用选择方式" class="headerlink" title="使用选择方式"></a>使用选择方式</h4><ul>
<li>当字符串相加操作或者改动较少时，建议使用String str = “hello”的形式</li>
<li>当字符串相加操作较多的情况下建议使用StringBuilder。如果使用了多线程，则使用StringBuffer</li>
</ul>
<h4 id="与equals"><a href="#与equals" class="headerlink" title="==与equals"></a>==与equals</h4><p><code>equals比较的是对象的内容也就是JVM堆内存中的内容，==比较的是地址即JVM栈内存中的内容</code></p>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><ul>
<li>string声明的字符串长度不可变是与StringBuilder与SringBuffer的最直观的区别。</li>
<li>string通过char数组保存字符串</li>
<li>对String对象的任何改变都不影响到原对象，任何的change操作都会生成新对象，比如substring,concat或replace在源码中的操作都不是在原有字符串上进行的么事重新生成了一个新的字符串对象。</li>
<li>string类的源码中 被final修饰  不能被继承（早起final修饰的方法会被转为内嵌调用以提升执行效率，现在的版本中已经渐渐被摒弃，所以现在不需要考虑用final去提升方法调用效率。只有不想让该方法被覆盖时才将方法设置为final）</li>
<li>类似 String s = “hello,world”创建时会在JVM的栈内存中产生一个变量 s ，同时在堆内存中产生”hello,world“字符串对象，s指向hello,world的内存地址。像上面这种方式产生的字符串属于<strong>直接量字符串</strong> (直接赋值的这种类型，<em>new String(“hello,world”)不会产生缓存,new关键字来生成对象都是在堆区进行的。而在堆区进行对象生成的过程是不会去检测对象是否已经存在的，因此通过new来创建对象，创建出的一定是不同的对象，及时字符串的内容是相同的</em>)对象，JVM在处理这类字符串的时候，会进行缓存，产生时放入字符串池，当程序需要再次使用的时候，无需重新创建一个新的字符串，而是直接指向已存在的字符串。如下代码打印结果为 true：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">        String s1 = <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;hello&quot;</span></span><br><span class="line">        String s3 = s2 + <span class="string">&quot;,world&quot;</span>;</span><br><span class="line">        System.out.println(s == s3);<span class="comment">//false</span></span><br><span class="line">        System.out.pringln(s.equals(s3));<span class="comment">//true</span></span><br><span class="line">        <span class="keyword">final</span> String s4 = <span class="string">&quot;hello&quot;</span>;<span class="comment">//对于被final修饰的变量，堆在class文件常量池中保存一个副本，也就是说不会通过连接而进行访问，对final边量的访问在编译期间都会直接被替代为真实的值。所以 String s5 = s4 + &quot;,world&quot;，实际上被JVM优化为 String s5 = &quot;hello&quot; +&quot;,world&quot;；等同于 String s5 = &quot;hello,world&quot;;但是如果final修饰的变量的结果是在运行时才能确定的，则 s4与s不是同一个对象</span></span><br><span class="line">        String s5 = s4 + <span class="string">&quot;,world&quot;</span>;</span><br><span class="line">      	String s6 = s2.concat(<span class="string">&quot;,world&quot;</span>);<span class="comment">//从末尾拼接</span></span><br><span class="line">        System.out.println(s == s5);<span class="comment">//true</span></span><br><span class="line">        System.out.println(s.equals(s5));<span class="comment">//true</span></span><br><span class="line">      	System.out.println(s == s6);<span class="comment">//false</span></span><br><span class="line">      	System.out.println(s.equals(s6))<span class="comment">//true</span></span><br><span class="line">        System.out.println(s == s1);<span class="comment">//true</span></span><br><span class="line">        String s7 = <span class="keyword">new</span> String(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">        String s8 = s7.intern();<span class="comment">//当调用s.intern()这句的时候，先去字符串常量池中找，是否有abc这个串，如果没有，则新增，同时返回引用，如果有，则返回已经存在的引用;</span></span><br><span class="line">        System.out.println(s == s7);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s == s8);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>用上述方法声明的string对象是固定的但是其所指向的对象可以发生变化，即s是引用变量。当声明s后，如出现 s = s +”a”;代码  则 s指向 ”hello,worlda“此字符串，但是s对象未发生变化，只是指向的对象发生变化。</p>
</li>
<li><p>String初始化方式(常用)</p>
<p>①  String s = “hello,world” 属于直接量字符串，并且当 String s1 = “hello,world”出现在同一代码段中时，s == s1 &amp;&amp; s.equlas(s2)。因为 直接量的字符串会产生缓存池，所以，当声明s1的时候，编译器检测到缓存池中存在相同的字符串，所以就直接使用。两者栈内存地址相同，并且堆内存指向的内容相同。</p>
<p>② String()  初始化一个String对象，表示一个空字符序列</p>
<p>③String(String value) 利用一个直接量创建一个新串</p>
<p>④String(char[] value) 利用一个字符数组创建</p>
<p>⑤String(char[] value,int offset,int count) 截取字符数组，从offset开始count个字符创建</p>
<p>⑥String(StringBuffer buffer);等同于 buffer.toString(); 同StringBuilder;`</p>
</li>
<li><p>字符串比较大小</p>
<p>从第一位开始  两个字符串同时比较字符的ASCII码值；如 a &lt; bc 、  ac&lt;bc 、  b&gt; ac </p>
</li>
</ul>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul>
<li><p><strong>String s = “123” + “456”内存中产生几个字符串对象？</strong></p>
<p>因为前面提到Java字符串的缓存，编译器在编译的时候会进行优化，所以 “123”与“456”被合成一个串“123456”,所以如果缓存池中没有“123456”这个对象，则会产生一个，且栈中产生一个引用s指向他，如果已存在那么产生0个对象，直接用s指向它。</p>
</li>
</ul>
<ul>
<li><p><strong>如果spilt()函数的参数在要分割的字符串中没有怎么办？如String s = “helloworld” ,我现在调用String[] s2 = s.spilt(“abc”)，返回什么？</strong></p>
<p>s2 为 helloworld</p>
</li>
</ul>
<ul>
<li><p><strong>判断</strong></p>
<p>String s = “ab” ; String s1 = “a”; String s2 = s1 +”b” ; String s3 = “ab”;</p>
<p><strong>s == s3 —&gt; true</strong></p>
<p><strong>s == s2 —&gt;false</strong>  s1+”b”产生了新对象 ， 栈内存中的地址不相同</p>
<p><strong>s.equals(s2) —&gt;true</strong>  堆内存的内容相同 </p>
</li>
<li><p><strong>String str = new String(“abc”)产生几个对象</strong></p>
<p>在运行期间创建一个对象，即在堆上创建了“abc”对象。涉及到两个对象，还有一个是在类加载的过程中在运行时常量池中创建了一个“abc”对象</p>
</li>
</ul>
<ul>
<li><p><strong>String str1 = “I”; str1 += “love” + “java”</strong>(1)和<strong>String str1 = “I”; str1 = str1 + “love” + “java”</strong>(2)的区别</p>
<p>1的效率比2高，1中的“love”+”java”在编译期间会被优化成“lovejava”而2中的不会被优化。前面说到过 s +=”hello”会被优化为StringBuilder 1会进行1次append而2会进行两次append操作</p>
</li>
</ul>
<h4 id="StringBuffer与StringBuilder"><a href="#StringBuffer与StringBuilder" class="headerlink" title="StringBuffer与StringBuilder"></a>StringBuffer与StringBuilder</h4><p><code>与String不同，StringBuffer与StringBuilder类的对象能够被多次的修改，并且不产生新的对象。</code></p>
<p><code>StringBuilder和StringBuffer类拥有的成员属性以及成员方法基本相同</code></p>
<p><code>StringBuilder与StringBuffer之间最大的不同是在于StringBuilder的方法不是线程安全的（不能同步访问）体现在StringBuffer在类的成员方法前面对了一个关键字：synchronized </code></p>
<p><code>StringBuilder比StringBuffer有速度优势，所以多数情况建议使用StringBuilder类，然而在程序要求线程安全的情况下，必须使用StringBuffer类</code></p>
<p><code>string+=&quot;hello&quot;的操作事实上会被JVM优化成</code></p>
<p><code>StringBuider str = new StringBuilder(string);</code></p>
<p><code>str.append(&quot;hello&quot;);</code></p>
<p><code>str.toString();</code></p>
<p><code>所以对String生成的字符串进行操作时都会生成新对象，如果使再循环中进行字符串的操作，用String这种类型会产生大量的对象，如果不进行垃圾回收，会造成很大的内存资源浪费。</code></p>
<ol>
<li>append() 将指定的字符串追加到此字符串尾部</li>
<li>reverse() 反转字符串</li>
<li>delete(int start,int end) 移除次序列的子字符串中的字符</li>
<li>insert(int offset,object i) 将 object （int 、string、double。。。。）参数的字符串表示形式插入到此序列中</li>
<li>replace(int start,int end,String str) 使用给定String中的字符替换此序列的子字符串中的字符</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *代码示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStringBuffer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        stringBuffer.append(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        System.out.println(stringBuffer);</span><br><span class="line">        stringBuffer.reverse();</span><br><span class="line">        System.out.println(stringBuffer);</span><br><span class="line">        stringBuffer.delete(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        System.out.println(stringBuffer);</span><br><span class="line">        stringBuffer.insert(<span class="number">0</span>,<span class="string">&quot;6&quot;</span>);</span><br><span class="line">        System.out.println(stringBuffer);</span><br><span class="line">        stringBuffer.replace(<span class="number">6</span>,<span class="number">6</span>,<span class="string">&quot;asd&quot;</span>);</span><br><span class="line">        System.out.println(stringBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> *结果输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="number">123456</span></span><br><span class="line"><span class="number">654321</span></span><br><span class="line"><span class="number">54321</span></span><br><span class="line"><span class="number">654321</span></span><br><span class="line"><span class="number">654321</span>asd</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>类与对象</title>
    <url>/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h4 id="类与对象关系、属性、方法与对象"><a href="#类与对象关系、属性、方法与对象" class="headerlink" title="类与对象关系、属性、方法与对象"></a>类与对象关系、属性、方法与对象</h4><p>类通常是一类事物的抽象，某个具体类的实例为对象，如 人为一个类，则你、我、他是这个类的具体实例，也就是对象。Java是面向对象的语言，每个对象都有自己的属性和方法，属性描述了类的特点，方法描述了类的功能。如肤色、身高是人的属性，吃喝玩是类的功能。</p>
<a id="more"></a>

<h4 id="封装、继承、多态"><a href="#封装、继承、多态" class="headerlink" title="封装、继承、多态"></a>封装、继承、多态</h4><p><code>封装：将抽象性函式接口的实现细节部分包装，隐藏起来，防止类的代码和数据被外部类定义的代码随机访问。可以通过接口暴露代码或数据。重要的功能是能修改自己实现的代码，而不用修改调用此代码的程序片段。</code></p>
<p><code>继承：继承就是子类继承父类的特征和行为。子类通过extend或implements声明继承父类，子类能继承父类非private的属性和方法，子类可以拥有自己的属性和方法。extend单一继承一个子类只能有一个父类。implements多继承一个子类可以有多个父类，父类的类型为interface。在类中super指向父类的引用，this指向本类的引用。</code></p>
<p><code>多态：方法的重载,参数多态,一个类中的多个方法，方法名相同，参数列表不同/个数不同/返回值不同。方法的重写覆盖,对于父类中的某个方法,在子类重新定义一个相同形态的方法。即多态的实现为重写或接口</code></p>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><ul>
<li>抽象类用abstract声明。</li>
<li>抽象类不能被实例化、其他特性与普通类相同，如属性，方法等。</li>
<li>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
<li>抽象类中可以有不抽象的方法，但包含抽象方法的类一定是抽象类。</li>
<li>任何类继承抽象类必须实现抽象方法，或者声明自身为抽象类。</li>
<li>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</li>
<li>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</li>
</ul>
<p><code>抽象类实例如下</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h4><ul>
<li>在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</li>
<li>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</li>
<li>类描述对象的属性和方法。接口则包含类要实现的方法。</li>
<li>接口没有构造方法。</li>
<li>接口中所有的方法必须是抽象方法。</li>
<li>接口不能包含成员变量，除了 static 和 final 变量。</li>
<li>接口不是被类继承了，而是要被类实现。</li>
<li>接口支持多继承。</li>
<li>接口不能用于实例化对象。</li>
<li>接口中的方法会被隐式的指定为 <strong>public abstract</strong>（只能是 public abstract，其他修饰符都会报错）。</li>
<li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 <strong>public static final</strong> 变量（并且只能是 public，用 private 修饰会报编译错误）。</li>
<li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</li>
<li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li>
<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <strong>public static final</strong> 类型的。</li>
<li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
<li>接口是隐式抽象的，当声明一个接口的时候，不必使用<strong>abstract</strong>关键字。</li>
<li>接口中每一个方法也是隐式抽象的，声明时同样不需要<strong>abstract</strong>关键字。</li>
<li>接口中的方法都是公有的。（public）</li>
</ul>
<p><code>接口类实例，以及抽象类继承接口类</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">interface</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String FORWHO = <span class="string">&quot;animal&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> alive  = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span>  <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">think</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Action.FORWHO);</span><br><span class="line">        System.out.println(<span class="string">&quot;animals can walk&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类的创建及初始化"><a href="#类的创建及初始化" class="headerlink" title="类的创建及初始化"></a>类的创建及初始化</h4><p><code>在面向对象的思想中，一切物体皆对象，我们以对象为单位进行编程，将这个对象所有的属性方法包装在一起，就是封装。一般情况，我们通过类的构造器来创建类对象，构造器是一个拥有和类名同样的名字的方法，我们可以对它传递参数，进行一些初始化工作。</code></p>
<p><code>当类中没有显式的声明构造方法时，编译器会自动生成空参数的构造方法，如下列代码,程序执行后输出10说明person对象创建成功</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	String name = <span class="string">&quot;10&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    System.out.println(person.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>但是当我们手动添加一个带有参数的构造函数，如下面第一段代码，编译时会报错，因为在java中如果我们声明了带参数的构造函数后，如果想使用不带参数的构造函数则必须将无参构造函数显式的声明出来。</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *错误</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name = <span class="string">&quot;10&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(person.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *正确</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name = <span class="string">&quot;10&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(person.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类属性方法的初始化顺序"><a href="#类属性方法的初始化顺序" class="headerlink" title="类属性方法的初始化顺序"></a>类属性方法的初始化顺序</h4><p><code>观察下列代码</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;this is static in Person&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(int id) &#123;</span><br><span class="line">        System.out.println(&quot;person(&quot; + id + &quot;)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Build b &#x3D; new Build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Build&#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;this is static in Build&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Person p1 &#x3D; new Person(1);</span><br><span class="line"></span><br><span class="line">    public Build() &#123;</span><br><span class="line">        System.out.println(&quot;this is build&#39;s block!&quot;);</span><br><span class="line">        Person p2 &#x3D; new Person(2);</span><br><span class="line">    &#125;</span><br><span class="line">    Person p3 &#x3D; new Person(3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>此段代码运行后输出结果为</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this is static in Person</span><br><span class="line">this is static in Build</span><br><span class="line">person(1)</span><br><span class="line">person(3)</span><br><span class="line">this is build&#39;s block!</span><br><span class="line">person(2)</span><br></pre></td></tr></table></figure>

<p><code>此段代码的运行结果说明，在一个类的初始化过程中，静态代码块里的程序最先执行，之后为属性的初始化，并且无论属性所处位置如何，属性的初始化顺序大于方法的初始化顺序，包括构造方法。</code></p>
<p><code>现在我们改一下上述代码观察一下静态代码块与非静态代码块</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is non-static&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is static in Person&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;person(&quot;</span> + id + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="number">1</span>);</span><br><span class="line">        Person person1 = <span class="keyword">new</span> Person(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>此程序运行后，输出结果为：</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this is static in Person</span><br><span class="line">this is non-static</span><br><span class="line">person(1)</span><br><span class="line">this is non-static</span><br><span class="line">person(2)</span><br></pre></td></tr></table></figure>

<p><code>我们发现，在两次初始化过程中，非静态代码块执行了两次，而静态代码块执行了一次，并且执行顺序在非静态代码块前。这说明，在类的初始化过程中，静态代码块在程序声明周期中最多运行一次。静态代码块是在类的装载时期（加入.class文件时）运行的，而非静态代码块在构造方法之前运行</code></p>
<p><code>对于静态块和静态属性，执行顺序在与其在代码中的顺序，非静态块和属性同上</code></p>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p><code>被static修饰的变量或方法都属于类变量、类方法，属于类的属性信息（在方法去分配内存），如静态块一样，其它的静态数据也具有这个特点：初始化只在类装载的时候执行一次。对于类变量和类方法，还有一个重要的特点就是，外部对象对他们的引用可以直接通过类名来调用，如上述抽象类中打印接口Action的FORWHO</code></p>
<h4 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h4><p><code>protected的权限控制在包内</code></p>
<h4 id="java-不定参数调用"><a href="#java-不定参数调用" class="headerlink" title="java 不定参数调用"></a>java 不定参数调用</h4><p><code>观察下列代码</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String ... value)</span></span>&#123;</span><br><span class="line">        System.out.println(value[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;length:&quot;</span> +value.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(person.test(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;bc&quot;</span>,<span class="string">&quot;d&quot;</span>));</span><br><span class="line">        System.out.println(person.test(<span class="string">&quot;123124&quot;</span>,<span class="string">&quot;345234&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>程序输出结果为</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">length:3</span><br><span class="line">123124</span><br><span class="line">length:2</span><br></pre></td></tr></table></figure>

<p><code>可以看出，参数是数组</code></p>
<h4 id="内部类创建"><a href="#内部类创建" class="headerlink" title="内部类创建"></a>内部类创建</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;a is print&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;b is print&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        InnerClass ic = <span class="keyword">new</span> InnerClass();</span><br><span class="line">        A  a = ic.<span class="function">new <span class="title">A</span><span class="params">()</span></span>;</span><br><span class="line">        InnerClass.B  b = <span class="keyword">new</span> B();</span><br><span class="line">        a.a();</span><br><span class="line">        b.b();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>java支持中文的类名方法名如下列代码</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 学生</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> 说()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="循环中止"><a href="#循环中止" class="headerlink" title="循环中止"></a>循环中止</h4><p><code>break:中止循环</code></p>
<p><code>continue:跳出当前循环进行下一循环</code></p>
<p><code>多层循环跳出时定义一个label，在需要跳出的地方使用 break label即可，如下列代码</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BreakUse &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        loop:for (int i &#x3D; 0;i &lt; 10;i++)&#123;</span><br><span class="line">            for(int j &#x3D; 10;j &gt; 0;j--)&#123;</span><br><span class="line">                if(i &gt;5 &amp;&amp; j&lt;9)&#123;</span><br><span class="line">                    System.out.println(&quot;i:&quot;+i+&quot;,j:&quot;+j);</span><br><span class="line">                    break loop;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>输出结果为</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i:6,j:8</span><br></pre></td></tr></table></figure>



<h4 id="继承时父类子类的构造器"><a href="#继承时父类子类的构造器" class="headerlink" title="继承时父类子类的构造器"></a>继承时父类子类的构造器</h4><p><code>在对子类进行初始化时，先调用父类的构造函数，如下列代码</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExtends</span> <span class="keyword">extends</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestExtends</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testExtends&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> TestExtends();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>输出结果为</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test</span><br><span class="line">testExtends</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>类加载机制</title>
    <url>/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="1、什么是类加载器"><a href="#1、什么是类加载器" class="headerlink" title="1、什么是类加载器"></a>1、什么是类加载器</h1><p>负责读取java字节代码，并转化成java.lang.Class类的一个实例。</p>
<a id="more"></a>

<h1 id="2、类加载器与类的“相同”判断"><a href="#2、类加载器与类的“相同”判断" class="headerlink" title="2、类加载器与类的“相同”判断"></a>2、类加载器与类的“相同”判断</h1><ul>
<li>类加载器除了用于加载类外，还可用于确定类在Java虚拟机中的唯一性。</li>
<li>即便是同样的字节代码，被不同的类加载器加载之后得到的类也是不同的。</li>
<li>通俗一点来讲，要判断两个类是否“相同”，前提是这两个类必须被同一个类加载器加载，否则这个两个类不“相同”。</li>
<li>这里的相同，包括Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法、instanceof关键字等判断出来的结果。</li>
</ul>
<h1 id="3、类加载器种类"><a href="#3、类加载器种类" class="headerlink" title="3、类加载器种类"></a>3、类加载器种类</h1><ul>
<li>启动类加载器，Bootstrap ClassLoader 加载JAVA_HOME\lib 或者被-Xbootclasspath参数限定的类</li>
<li>扩展类加载器、Extension ClassLoader 加载\lib\ext,或者被java.ext.dirs系统变量指定的类</li>
<li>应用程序类加载器，Application ClassLoader，加载ClassPath中的类库.</li>
<li>自定义类加载器，通过集成ClassLoader实现，一般是加载我们的自定义类。</li>
</ul>
<h1 id="4、双亲委派模型"><a href="#4、双亲委派模型" class="headerlink" title="4、双亲委派模型"></a>4、双亲委派模型</h1><p>类加载器Java类如同其他的Java类一样，也是要由类加载器来加载的；除了启动类加载器，每个类都有其父类加载器（父子关系由组合（不是继承来实现））；</p>
<p>所谓双亲委派是指每次收到类加载请求时，先将请求委派给父类加载器完成（所有加载请求最终会委派到顶层的Bootstrap ClassLoader加载器中），如果父类加载器无法完成这个加载（该加载器的搜索范围中没有找到对应的类），子类尝试自己加载。</p>
<p>![](879896-20160415085506488-408997874 (1).png)</p>
<h2 id="双亲委派好处"><a href="#双亲委派好处" class="headerlink" title="双亲委派好处"></a>双亲委派好处</h2><ul>
<li>避免同一个类被多次加载</li>
<li>每个加载器只能加载自己范围内的类；</li>
</ul>
<h1 id="5、类加载过程"><a href="#5、类加载过程" class="headerlink" title="5、类加载过程"></a>5、类加载过程</h1><p>类加载分为三个步骤：<strong>加载</strong>，<strong>连接</strong>，<strong>初始化</strong>；</p>
<p>如下图 , 是一个类从加载到使用及卸载的全部生命周期，图片来自参考资料；</p>
<p><img src="/.com//879896-20160414224549770-60006655.png"></p>
<p><strong>加载</strong> ：</p>
<ul>
<li>根据一个类的全限定名(如cn.edu.hdu.test.HelloWorld.class)来读取此类的二进制字节流到JVM内部;</li>
<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构（hotspot选择将Class对象存储在方法区中，Java虚拟机规范并没有明确要求一定要存储在方法区或堆区中）</li>
<li>转换为一个与目标类型对应的java.lang.Class对象；</li>
</ul>
<p><strong>连接</strong></p>
<ul>
<li>验证<ul>
<li>验证阶段主要包括四个验证过程：文件格式验证、元数据验证、字节码验证和符号引用验证。</li>
</ul>
</li>
</ul>
<ul>
<li>准备<ul>
<li>为类中的所有静态变量分配内存空间，并为其设置一个初始值（由于还没有产生对象，实例变量将不再此操作范围内）；</li>
</ul>
</li>
</ul>
<ul>
<li>解析<ul>
<li>将常量池中的所有符号引用转为直接引用（得到类或者字段、方法在内存中的指针或者偏移量，以便直接调用该方法）。这个阶段可以在初始化之后再执行。</li>
</ul>
</li>
</ul>
<p><strong>初始化</strong></p>
<p> 在连接的准备阶段，类变量已赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员自己写的逻辑去初始化类变量和其他资源，举个例子如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int value1  &#x3D; 5;</span><br><span class="line">public static int value2  &#x3D; 6;</span><br><span class="line">static&#123;</span><br><span class="line">    value2 &#x3D; 66;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在准备阶段value1和value2都等于0；</p>
<p>在初始化阶段value1和value2分别等于5和66；</p>
<ul>
<li>所有类变量初始化语句和静态代码块都会在编译时被前端编译器放在收集器里头，存放到一个特殊的方法中，这个方法就是<clinit>方法，即类/接口初始化方法，该方法只能在类加载的过程中由JVM调用；</clinit></li>
<li>编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量；</li>
<li>如果超类还没有被初始化，那么优先对超类初始化，但在<clinit>方法内部不会显示调用超类的<clinit>方法，由JVM负责保证一个类的<clinit>方法执行之前，它的超类<clinit>方法已经被执行。</clinit></clinit></clinit></clinit></li>
<li>JVM必须确保一个类在初始化的过程中，如果是多线程需要同时初始化它，仅仅只能允许其中一个线程对其执行初始化操作，其余线程必须等待，只有在活动线程执行完对类的初始化操作之后，才会通知正在等待的其他线程。(所以可以利用静态内部类实现线程安全的单例模式)</li>
<li>如果一个类没有声明任何的类变量，也没有静态代码块，那么可以没有类<clinit>方法；</clinit></li>
</ul>
<p>类初始化何时触发：</p>
<ol>
<li><strong>为一个类型创建一个新的对象实例时（比如new、反射、序列化）</strong></li>
<li><strong>调用一个类型的静态方法时（即在字节码中执行invokestatic指令）</strong></li>
<li><strong>调用一个类型或接口的静态字段，或者对这些静态字段执行赋值操作时（即在字节码中，执行getstatic或者putstatic指令），不过用final修饰的静态字段除外，它被初始化为一个编译时常量表达式</strong></li>
<li><strong>调用JavaAPI中的反射方法时（比如调用java.lang.Class中的方法，或者java.lang.reflect包中其他类的方法）</strong></li>
<li><strong>初始化一个类的派生类时（Java虚拟机规范明确要求初始化一个类时，它的超类必须提前完成初始化操作，接口例外）</strong></li>
<li><strong>JVM启动包含main方法的启动类时。</strong></li>
</ol>
<h1 id="6、自定义类加载器"><a href="#6、自定义类加载器" class="headerlink" title="6、自定义类加载器"></a>6、自定义类加载器</h1><p> 要创建用户自己的类加载器，只需要继承java.lang.ClassLoader类，然后覆盖它的findClass(String name)方法即可，即指明如何获取类的字节码流。</p>
<p>**如果要符合双亲委派规范，则重写findClass方法（用户自定义类加载逻辑）；要破坏的话，重写loadClass方法(双亲委派的具体逻辑实现)**。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String classPath;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String classPath)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classPath = classPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = getData(name);</span><br><span class="line">        <span class="keyword">if</span>(classData == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name,classData,<span class="number">0</span>,classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getData(String className)&#123;</span><br><span class="line">        String path = classPath + File.separatorChar</span><br><span class="line">                +className.replace(<span class="string">&#x27;.&#x27;</span>,File.separatorChar)+<span class="string">&quot;.class&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            InputStream is = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">            ByteArrayOutputStream stream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>];</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((num=is.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                stream.write(buffer,<span class="number">0</span>,num);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stream.toByteArray();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ClassLoader pcl = <span class="keyword">new</span> PathClassLoader(<span class="string">&quot;F:\\ideaworkspace\\learn\\simpleioc\\src\\main\\java&quot;</span>);</span><br><span class="line">        Class c = pcl.loadClass(<span class="string">&quot;com.lichaobao.simpleioc.classloader.TestClassLoad&quot;</span>);</span><br><span class="line">        System.out.println(c.newInstance());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClassLoad</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;类加载成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7、JAVA热部署实现"><a href="#7、JAVA热部署实现" class="headerlink" title="7、JAVA热部署实现"></a>7、JAVA热部署实现</h1><p>首先谈一下何为热部署（hotswap），热部署是在不重启 Java 虚拟机的前提下，能自动侦测到 class 文件的变化，更新运行时 class 的行为。</p>
<p>Java 类是通过 Java 虚拟机加载的，某个类的 class 文件在被 classloader 加载后，会生成对应的 Class 对象，</p>
<p>之后就可以创建该类的实例。默认的虚拟机行为只会在启动时加载类，如果后期有一个类需要更新的话，单纯替换编译的 class 文件，Java 虚拟机是不会更新正在运行的 class。如果要实现热部署，最根本的方式是修改虚拟机的源代码，改变 classloader 的加载行为，使虚拟机能监听 class 文件的更新，重新加载 class 文件，这样的行为破坏性很大，为后续的 JVM 升级埋下了一个大坑。</p>
<p>另一种友好的方法是创建自己的 classloader 来加载需要监听的 class，这样就能控制类加载的时机，从而实现热部署。 </p>
<p> 热部署步骤：</p>
<ol>
<li>销毁自定义classloader(被该加载器加载的class也会自动卸载)；</li>
<li>更新class</li>
<li>使用新的ClassLoader去加载class </li>
</ol>
<p>JVM中的Class只有满足以下三个条件，才能被GC回收，也就是该Class被卸载（unload）：</p>
<ul>
<li>该类所有的实例都已经被GC，也就是JVM中不存在该Class的任何实例。</li>
<li>加载该类的ClassLoader已经被GC。</li>
<li>该类的java.lang.Class 对象没有在任何地方被引用，如不能在任何地方通过反射访问该类的方法</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内存管理以及垃圾回收</title>
    <url>/JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%BB%A5%E5%8F%8A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<h3 id="Java-内存结构以及垃圾回收"><a href="#Java-内存结构以及垃圾回收" class="headerlink" title="Java 内存结构以及垃圾回收"></a>Java 内存结构以及垃圾回收</h3><h4 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h4><h5 id="java7"><a href="#java7" class="headerlink" title="java7"></a>java7</h5><p><img src="/.com//java7%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png"></p>
<a id="more"></a>
<p><img src="/.com//JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png"></p>
<p><img src="/.com//TIM%E5%9B%BE%E7%89%8720190715103024.png"></p>
<p><img src="/.com//TIM%E5%9B%BE%E7%89%8720190715103134.png"></p>
<p>一般将-Xmx -Xms 设置为一样，因为当heap不够用进行扩容时会发生抖动，影响程序运行的稳定性。</p>
<p><img src="/.com//TIM%E5%9B%BE%E7%89%8720190715103431.png"></p>
<p><img src="/.com//TIM%E5%9B%BE%E7%89%8720190715103647.png"></p>
<p><img src="/.com//TIM%E5%9B%BE%E7%89%8720190715103910.png"></p>
<p><img src="/.com//TIM%E5%9B%BE%E7%89%8720190715104149.png"></p>
<p><img src="/.com//TIM%E5%9B%BE%E7%89%8720190715104258.png"></p>
<p><img src="/.com//TIM%E5%9B%BE%E7%89%8720190715104408.png"></p>
<p>JDK6：当调用intern方法时，如果字符串常量池先前已创建出该字符串对象，则返回池中该字符串的引用，否则，将此字符串对象添加到<u>字符串常量池</u>中，并且返回该字符串的引用。</p>
<p>JDK6+：当调用intern方法时，如果字符串常量池先前已创建出该字符串对象，则返回池中该字符串的引用，否则，如果字符串对象已经存在于==Java堆==中，则将堆中的对此对象的引用添加到字符串常量池中，并且返回该引用，如果堆中不存在，则在池中创建该字符串并返回其引用</p>
<p><img src="/.com//TIM%E5%9B%BE%E7%89%8720190715112834.png"></p>
<h5 id="程序计数器-Program-Counter-Register"><a href="#程序计数器-Program-Counter-Register" class="headerlink" title="程序计数器(Program Counter Register)"></a>程序计数器(Program Counter Register)</h5><ul>
<li><code> 线程私有。代码的运行时有顺序的，但当cpu在多线程切换时，当从A线程切换到B线程，在切回到A线程时，cpu如何知道该从A线程的哪里继续执行呢？cpu工作时就是根据每个线程的程序计数器的值来选取下一条需要执行的字节码指令，即“找到它离开时的位置来继续执行”。需要提示的是，当CPU执行的是一个Java方法时，程序计数器记录的是正在执行的虚拟机字节码指令的地址。如果执行的是Native方法（java调用非java代码的接口），这个计数值为undefined，即不发挥作用</code></li>
</ul>
<ul>
<li><code>程序计数器是线程私有的一块较小的内存空间，直接划分在CPU上，程序员无法直接操作它。作用：JVM在解释字节码文件（.class）时，存储当前线程所执行的字节码的行号。是一种概念模型，各种JVM所采取的方式不同。</code></li>
</ul>
<ul>
<li><code>是唯一一个在Java规范中没有任何OutOfMemoryError情况的区域</code></li>
</ul>
<ul>
<li><code>分支、循环、跳转等基础功能都是依赖此技术区完成的</code></li>
</ul>
<ul>
<li><code>线程时CPU调度的基本单位，多线程情况下，线程数超过CPU内核数量时，线程之间就要根据时间片轮询抢夺CPU时间资源，因此，为了线程切换后能够恢复到正确的执行位置，每条线程都需要一个独立的程序计数器去记录正在执行的字节码指令地址</code></li>
</ul>
<h5 id="虚拟机栈-JVM-Stacks"><a href="#虚拟机栈-JVM-Stacks" class="headerlink" title="虚拟机栈(JVM Stacks)"></a>虚拟机栈(JVM Stacks)</h5><p><code>是描述Java方法执行的内存模型</code></p>
<p><code>线程私有。JVM虚拟机栈就是我们常说的堆栈的栈（我们常常把内存粗略的分为堆和栈），生命周期和线程一样，每个方法被执行的时候都会产生一个栈帧，用于存储局部变量表，动态链接、操作数、方法出口等信息。</code></p>
<p><code>方法的执行过程就是栈帧在JVM中出栈和入栈的过程</code></p>
<p><code>局部变量表中存放的是各种基本数据类型，如：（int, short, long, byte, float, double, boolean, char）和 对象句柄（即引用类型（存放的是指向个个对象的内存地址））。他们可以是方法参数，也可以是方法的局部变量。因此，他有一个特点，内存空间可以在编译期间就确定，运行期不在改变。这个区域有两种可能的Java异常：StackOverFlowError和OutOfMemporyError</code></p>
<p><code>我们知道，一个线程拥有一个自己的栈，这个栈的大小决定了方法调用的可达深度（递归多少层次，或者嵌套调用多少层其他方法，-Xss参数可以设置虚拟机栈大小），若线程请求的栈深度大于虚拟机允许的深度，则抛出StackOverFlowError异常。</code></p>
<p>==栈的大小可以使固定的，也可以是动态扩展的，若虚拟机可以动态扩展（大多数虚拟机都可以），但拓展时无非申请到足够的内存（比如没有足够的内存为一个新创建的线程分配栈空间时）则抛出OutofMemoryError异常==</p>
<p>栈帧结构图：</p>
<p><img src="https://img-blog.csdn.net/20170505082120037?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>
<h5 id="本地方法栈-Native-Method-Stacks"><a href="#本地方法栈-Native-Method-Stacks" class="headerlink" title="本地方法栈(Native Method Stacks)"></a>本地方法栈(Native Method Stacks)</h5><p><code>本地方法栈就是用来处理Java中的本地方法的，java类的祖先类Object中有众多的Native方法，如hashCode()、wait()等，他们的执行很多时候是借助于操作系统，但是JVM需要对他们做一些规范，来处理他们的执行过程。</code></p>
<p><code>本地方法栈与虚拟机栈发挥的作用是非常相似的，他们之间的区别不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈为虚拟机执行Native方法服务。与虚拟机栈一样，本地方法栈区域也会抛出 StackOverflowError 和 OutOfMemoryError 异常。</code></p>
<p><code>由于虚拟机规范对于本地方方法栈的具体实现没有强制要求，所以可以有不同的实现方法，比如Sun HotSpot直接把本地方法栈和虚拟机栈合二为一</code></p>
<h5 id="Java堆-Head"><a href="#Java堆-Head" class="headerlink" title="Java堆(Head)"></a>Java堆(Head)</h5><p>堆内存是java内存模型中最重要的一块，也是最有必要进行深究的一部分，因为java性能的优化主要就是针对这部分。涉及到内存的分配(new 关键字、反射等)与回收(回收算法，收集器等)。</p>
<p>堆的唯一目的就是==存放对象实例==，几乎所有的对象实例（和数组）都在这里分配内存。类的对象从中分配空间，这些对象通过new、newarray、anewarray和multianewarray等指令建立，他们不需要程序代码来显示的释放。</p>
<p>java规范中的描述：所有对象实例以及数组都要在堆上分配。</p>
<p>线程共享</p>
<p>线程共享的Java堆可能分出<u>多个线程私有的分配缓冲区</u>(<strong>TLAB</strong>,这是为了并发分配内存时的脏分配问题，需要使用相关参数来开启。虚拟机默认使用CAS加上失败重试机制解决脏分配问题)</p>
<p>Java堆在HotSpot中的实现是可拓展的</p>
<p>由于Java堆唯一目的就是用来存放对象实例，因此其也是垃圾收集器管理的主要区域，故也称为GC堆</p>
<p>从内存回收的角度看，由于现在的垃圾收集器基本都采用<strong>分代收集</strong>算法，所以为了方便垃圾回收，Java堆还可以分为<strong>新生代和老年代</strong>。</p>
<p>新生代用于存放刚创建的对象以及年轻的对象，如果对象一直么有被回收，生存的足够长，对象就会被移入老年代，新生代有可进一步细分为 eden、survivorSpace0和survivorSpace1。刚创建的对象都放入eden,s0、s1都至少经过一次GC并幸存。如果幸存对象经过一定时间仍存在，则进入老年代。</p>
<p><img src="https://img-blog.csdn.net/20170505083056192?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>
<p><code>java堆可以处在物理上不连续的内存空间中，只要逻辑上是连续的即可。</code></p>
<h6 id="TLAB-Thread-Local-Allocation-Buffer-线程私有分配缓冲区"><a href="#TLAB-Thread-Local-Allocation-Buffer-线程私有分配缓冲区" class="headerlink" title="TLAB(Thread Local Allocation Buffer,==线程私有分配缓冲区==)"></a>TLAB(Thread Local Allocation Buffer,==线程私有分配缓冲区==)</h6><p>Sun Hotspot JVM 为了提升对象内存分配的效率，对于所创建的线程，都会分配一块堆里的空间TLAB，其大小由JVM根据运行的情况计算而得。在TLAB上分配对象时<u>不需要加锁</u>（相对于CAS配上失败重试方式），因此JVM再给线程的对象分配内存时会尽量的在TLAB上分配，在这种情况下JVM中分配对象内存的性能和C基本上是一样高效的，但如果对象过大的话则仍然是直接使用堆空间分配。</p>
<p>虚拟机为新生对象分配内存时，需要考虑修改指针 (该指针用于划分内存使用空间和空闲空间) 时的线程安全问题，因为存在可能出现正在给对象A分配内存，指针还未修改，对象B又同时使用原来的指针分配内存的情况。TLAB 的存在就是为了解决这个问题：每个线程在Java堆中预先分配一小块内存 TLAB，<strong>哪个线程需要分配内存就在自己的TLAB上进行分配</strong>，若TLAB用完并分配新的TLAB时，再加同步锁定，这样就大大提升了对象内存分配的效率</p>
<h5 id="方法区-永久代、Method-Area-（1-7）"><a href="#方法区-永久代、Method-Area-（1-7）" class="headerlink" title="方法区(永久代、Method Area)（1.7）"></a>方法区(永久代、Method Area)（1.7）</h5><p>方法区是所有线程共享的内存区域，用于存储==已经被JVM加载的类信息、常量、静态变量等数据==。</p>
<p>java规范将方法区描述为堆的一个逻辑部分，但是它不是堆，又称为非堆</p>
<p><strong>运行时常量池</strong> :（1.7以后在堆中）方法区重要概念，主要用于存放==在编译过程中就产生的字面量和符号引用==。其中，字面量比较接近Java语言层次的常量概念，如<u>文本字符串、被声明为final的常量值</u>等；而符号引用则属于编译原理方面的概念，包括以下三类常量：<u>类和接口的全限定名、字段的名称和描述符 和 方法的名称和描述符</u>。一般情况下，常量的内存分配在编译期间就能明确，但不一定全是。<u>有一些可能就是运行时==也可将常量放入常量池，如String类中有个Native方法intern()</u></p>
<p>运行时常量池相对于Class文件常量池的一个重要特征是<u>具备动态性</u>。</p>
<h5 id="元空间（MetaSpace）（1-8）与永久代（PermGen）的区别"><a href="#元空间（MetaSpace）（1-8）与永久代（PermGen）的区别" class="headerlink" title="元空间（MetaSpace）（1.8）与永久代（PermGen）的区别"></a>元空间（MetaSpace）（1.8）与永久代（PermGen）的区别</h5><p>java 8以后开始把类的元数据放在本地==堆==内存中，这一块区域就叫做==元空间== 。该区域在jdk1.7及以前是属于==永久代==的，元空间以及永久代都是用来<u>存储class的相关信息</u>，包括class对象的·method以及field。<u>这两个都系都是方法区的实现</u>，只是实现方法不同。<u>方法区只是jvm的规范</u>。在java7后原先位于方法区中的字符串常量池被移动到了java堆中并且在java8以后用==元空间替代了永久代==。</p>
<p>最大区别：==元空间使用本地内存、而永久代使用的是jvm内存==。这个替代的表现就为，在老版本jdk中java.lang.OutOfmemoryError:PermGen space这个异常不复存在。因为默认的类的元数据分配只收本地内存大小的限制。也就是理论上本地内存有多少，metaSpace就有多大。</p>
<p>替换优势：字符串常量池存在永久代中，==<u>容易出现性能问题和内存溢出</u>==。类和方法的信息大小难以确定，给永久代的大小指定带来了困难。永久代会为GC带来不必要的复杂性。方便HotSpot与其他JVM如Jrockit集成（其他的jvm没有永久代这一说）</p>
<h5 id="Java堆和方法区的区别"><a href="#Java堆和方法区的区别" class="headerlink" title="Java堆和方法区的区别"></a>Java堆和方法区的区别</h5><p>Java堆是Java代码可及的内存，是留给开发人员使用的；而<u>==非堆（Non-Heap）是JVM留给自己用的==</u>，所以方法区、jvm内部处理或优化所需内存（如JIT编译后的代码缓存）、每个类结构（如运行时常量池、字段、方法数据）以及方法和构造方法的代码都在非堆内存中</p>
<h5 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h5><p>方法区的内存回收目标主要是针对==<u>常量池的回收和对类型的卸载</u>==。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，例如一个字符串“abc”已经进入了常量池中，但是当前系统没有一个String对象是叫做“abc”的，换句话说是没有任何String对象==引用==常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果在这时候发生内存回收，而且必要的话，这个“abc”常量就会被系统“请”出常量池，常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p>
<p>判断一个常量是否是“废弃常量”比较简单，而要判断一个类是否是“==无用的类==”的条件则相对苛刻许多，类需要同时满足下面三个条件才能算是“无用的类”</p>
<ul>
<li><u>该类所有的==实例都已经被回收==，也就是Java<strong>堆</strong>中不存在该类的任何实例；</u></li>
<li><u>加载该类的==ClassLoader==已经被回收</u></li>
<li><u>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过==反射==访问该类的方法。</u></li>
</ul>
<p>​      虚拟机可以对满足上述3个条件的无用类进行回收(卸载)，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会回收。特别地，在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出</p>
<h5 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h5><p>直接内存不是Java虚拟机规范的内存区域。但是这部分也被人频繁使用，会导致OutOfMemory异常</p>
<p>JDK1.4中加入的==NIO==，引入了一种<strong>基于通道与缓冲区的I/O方式</strong>，它们==可以使用Native函数库直接分配堆外内存==，即我们所说的直接内存，这样在某些场景中会提高程序的性能</p>
<h4 id="内存模型概述"><a href="#内存模型概述" class="headerlink" title="内存模型概述"></a>内存模型概述</h4><p>Java程序在执行前首先会被编译成字节码文件，然后再有Java虚拟机执行这些字节码文件从而使得Java程序得以执行。在程序执行过程中，内存的使用和管理一直是值得关注的问题，Java虚拟机在执行java程序的工程中会把它所管理的内存划分为若干个不同的数据区域，这些数据区域都有各自的用途，以及创建和销毁的时间</p>
<h5 id="数据区域两种类型"><a href="#数据区域两种类型" class="headerlink" title="数据区域两种类型"></a>数据区域两种类型</h5><ul>
<li>线程共享：方法区和堆</li>
<li>线程私有：虚拟机栈、本地方法栈、程序计数器</li>
</ul>
<h4 id="垃圾回收（Garbage-Collection-GC）"><a href="#垃圾回收（Garbage-Collection-GC）" class="headerlink" title="垃圾回收（Garbage Collection,GC）"></a>垃圾回收（Garbage Collection,GC）</h4><h5 id="为什么要进行垃圾回收"><a href="#为什么要进行垃圾回收" class="headerlink" title="为什么要进行垃圾回收"></a>为什么要进行垃圾回收</h5><p>随着程序的运行，内存中存在的实例对象、变量等信息占据的内存越来越多。如果不及时进行垃圾回收，必然会带来==程序性能==的下降，甚至会因为可用内存不足造成一些不必要的系统异常</p>
<h5 id="哪些垃圾需要回收"><a href="#哪些垃圾需要回收" class="headerlink" title="哪些垃圾需要回收"></a>哪些垃圾需要回收</h5><p>在以上的几大区中，有三个是不需要进行垃圾回收的：程序计数器、JVM栈、本地方法栈。因为他们的声明周期适合线程同步的，随着线程的销毁，他们占用的内存会自动释放，所以==只有方法区和堆需要进行GC==。具体到哪些对象的话，简单概括一句话：如果那个对象已经不存在任何引用，那么他可以被回收。通俗解释一下就是说，如果一个对象，已经没有什么作用了，就可以被当成废弃物被回收了。</p>
<h5 id="什么时候进行垃圾回收"><a href="#什么时候进行垃圾回收" class="headerlink" title="什么时候进行垃圾回收"></a>什么时候进行垃圾回收</h5><p>堆的新生代、老年代、永久代的垃圾回收时机，MinorGC和FullGC</p>
<p>根据一个经典的引用计数算法，每个对象添加一个<u>引用计数器</u>，每被引用一次，计数器加一，失去引用，计数器减一，当计数器在一段时间内保持为0时，该对象就认为是可以被回收的了。但是这个算法有明显的缺陷，当两个对象<u>相互引用</u>，但是两者已经没有作用时，按照常规，应该对其进行垃圾回收，但是其相互引用，又不符合此算法回收的条件，因此无法完美的处理这块内存清理。因此Sun的JVM并没有采用引用计数算法来进行垃圾回收。而是采用一个叫：==根搜索算法（可达性分析算法）==，如下图：</p>
<p><img src="http://static.zybuluo.com/Rico123/q0t6nxkafapyn6yql7benc32/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg"></p>
<p>基本思想就是：从一个GC Roots的对象开始，向下搜索，如果==一个对象不能到达GCRoots对象==的时候，说明他已经不在被<strong>引用</strong>，即可被进行垃圾回收（此处暂时这样理解，其实事实还有一些不同，当一个对象不在被引用时，并没有完全“死亡”，<u>如果类重写了finalize()方法，且没有被系统调用过，那么该对象可以“重生”</u>，如果不可以，那么说明彻底可以被回收了），如上图中的ObjectF、ObjectD、ObjectE，虽然他们三个依然可能相互引用，但是总体来说，他们已经没有作用了，这样就解决了引用计数算法无法解决的问题。</p>
<p>在Java中，可作为GC Root的对象包括以下几种：</p>
<ul>
<li>虚拟机栈(栈帧中的局部变量表中引用的对象)</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中Native方法引用的对象；</li>
</ul>
<h5 id="补充“引用”的概念"><a href="#补充“引用”的概念" class="headerlink" title="补充“引用”的概念"></a>补充“引用”的概念</h5><p>JDK1.2之后，对引用进行了扩充，引入了强、软、弱、虚四种引用，被标记为这四种引用的对象，在GC时分别有不同的意义：</p>
<p>a. 强引用（Strong Reference）就是为刚被new出来的对象所加的引用，他的特点是，==永远不会被回收==。</p>
<p>b.软引用（soft Reference） 声明为软引用的类，是可以被回收的对象。如果JVM内存不紧张时这类对象可以不被回收，如果内存紧张则会被回收。那为什么会不直接回收了它，原因是：我们知道，Java中是存在缓存机制的，就拿字面量缓存来说，有些时候，缓存的对象就是当前可有可无的，只是留在内存中，==如果还有需要，则不需要重新分配内存即可使用==，因此，这些对象即可被引用为软引用，方便使用，提高程序性能。</p>
<p>c. 弱引用（Weak Reference）弱引用的对象就是==一定需要进行垃圾回收的==，不管内存是否紧张，当进行GC时，标记为弱引用的对象一定会被清理回收。</p>
<p>d.虚引用（Phantom Reference）虚引用弱的可以忽略不计，JVM完全不在乎虚引用，其唯一作用就是做一些跟踪记录，辅助finalize函数的使用。</p>
<h5 id="如何回收"><a href="#如何回收" class="headerlink" title="如何回收"></a>如何回收</h5><p><code>三种经典得垃圾回收算法（标志清除算法、复制算法、标记整理算法）以及分代收集算法和七种垃圾收集器</code></p>
<h5 id="Stop-the-World"><a href="#Stop-the-World" class="headerlink" title="Stop-the-World"></a>Stop-the-World</h5><p>这意味着JVM由于要执行GC而停止了应用程序的执行，并且这种情形会在任何一种GC算法中发生。当Stop-the-World发生时，除了GC所需要的线程外，所有线程都处于==等待状态==直到GC任务完成。事实上，GC优化很多时候就是指减少Stop-the-world发生的时间，从而使系统具有==高吞吐、低停顿==的特点。</p>
<p>内存泄漏是指该==内存空间使用完毕之后未回收==，在不涉及复杂数据结构的一般情况下，Java的内存泄漏表现为==一个内存对象的生命周期超出了程序需要它的时间长度==。</p>
<h5 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h5><p>1、标记清除算法</p>
<p>标记清除算法分为标记和清除两个阶段。该算法首先从==根集合==进行扫描，==对存活的对象进行标记==，标记完毕后，在扫描整个空间中==未被标记==的对象进行回收，如下图所示。</p>
<p><img src="/.com//%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.jpg"></p>
<p>标记-清除算法的主要不足有两个：</p>
<ul>
<li>效率问题：标记和清除两个过程的效率都不高；</li>
<li>空间问题：标记清除算法<u>不需要进行对象的移动，并且仅对不存活的对象进行处理</u>，因此标记清除之后会产生==大量不连续的内存碎片==，空间碎片太多可能会导致以后<u>在程序运行过程中需要分配较大对象时，无法找到足够的连续内存</u>，而不得不提前触发另一次垃圾收集动作。</li>
</ul>
<p><img src="/.com//%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png"></p>
<p>2、复制算法</p>
<p>复制算法将==可用内存按照容量划分为大小相等的两块==，每次只是用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这种算法适用于==对象存活率低==的场景，比如==新生代==。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要==移动堆顶指针，按顺序分配内存==即可，实现简单，运行高效。复制算法示例图如下：</p>
<p><img src="/.com//%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.jpg"></p>
<p>事实上，现在商用的虚拟机都采用这种算法来回收新生代。因为研究发现，新生代中的对象每次回收基本上只有10%左右的对象存活，所以需要复制的对象很少，效率还不错。实践中会将新生代内存分为一块较大的Eden空间和两块较小的Survivor空间 (如下图所示)，==每次使用Eden和其中一块Survivor==。当回收时，将Eden和Survivor中还存活着的对象一次地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认==Eden和Survivor的大小比例是 8:1==，也就是每次新生代中可用内存空间为整个新生代容量的90% ( 80%+10% )，只有10% 的内存会被“浪费”。</p>
<p><img src="/.com//heap.bmp"></p>
<p>3、标记整理算法</p>
<p>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要额外的空间进行分配担保，以应对被使用的内存中==所有对象都100%存活的极端情况==，所以老年代一般不能直接选用这种算法。标记整理算法的标记过程类似标记清除算法，但后续步骤不是直接对可回收对象进行整理，而是让所有存活的对象都==向一端移动==，然后直接清理掉端边界以外的内存，类似于磁盘整理的过程，该垃圾回收算法适用于对象存活率高的场景（老年代），其作用原理如下图所示。</p>
<p><img src="/.com//%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%951.jpg"></p>
<p>标记整理算法与标记清除算法最显著的区别是：标记清除算法不进行对象的移动，并且仅对不存活的对象进行处理；而标记整理算法会将所有的存活对象移动到一端，并对不存活对象进行处理，因此其不会产生内存碎片。标记整理算法的作用示例图如下：</p>
<p><img src="/.com//%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p>
<p>4、分代收集算法</p>
<p>对于一个大型的系统，当创建的对象和方法变量比较多时，对内存中的对象也会比较多，如果逐一分析对象是否该回收，那么势必造成效率低下。分代收集算法是基于这样一个事实：不同的对象的生命周期（存活情况）是不一样的，而==不同生命周期的对象位于堆中不同的区域==，因此对堆内存不同区域采用不同的策略进行回收可以提高JVM的执行效率。当代商用虚拟机使用的都是分代收集算法：新生代对象存活率低，就采用复制算法；老年代存活率高就用标记清除算法或者标记整理算法。Java堆内存一般可以分为新生代、老年代。<u>老年代一般说归在方法区</u>（但是这种说法是不准确的）</p>
<p><img src="/.com//%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E6%80%BB.jpg"></p>
<h5 id="新生代、老年代、永久代详解"><a href="#新生代、老年代、永久代详解" class="headerlink" title="新生代、老年代、永久代详解"></a>新生代、老年代、永久代详解</h5><p>1、新生代（Young Generation）</p>
<p>新生代的目标就是尽可能快速的收集掉那些生命周期短的对象，一般情况下，所有新生成的对象都是放在新生代的，新生代内存按照==8:1:1==的比例分为一个 eden区和两个survivor(0,1)区，大部分对象在Eden区中生成。在进行垃圾回收时，==先将eden区存活对象复制到survivor0区然后清空eden区==，当这个survivor0区也满了时，==将eden区和survivor0区存活对象复制到survivor1区==，然后清空eden和这个survivor0区，此时survivor0区是空的，然后交换survivor0区和survivor1区的角色（即下次垃圾回收时会扫描Eden区和survivor1区），即==保持survivor0区是空的==，如此往复。特别的，当survivor1区也不足以存放eden区和survivor0区的存活对象时，就将存活对象==直接存放到老年代==。如果老年代也满了，就会触发一次==FullGC==,也就是新生代、老年代都进行回收。注意，新生代发生的GC也叫作MinorGC,MinorGC发生的频率比较高，不一定等Eden区满了才触发。</p>
<p>2、老年代（Old Generation）</p>
<p>老年代中存放的都是一些生命周期较长的对象，就像上面叙述的那样，==在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中==。此外==老年代的内存也比新生代大很多（大概是2:1）==当老年代满时会触发Major GC(Full GC)，老年代对象存活时间长，因此FullGC 发生的频率比较低。</p>
<p>3、永久代（Permanent Generation）</p>
<p>永久代主要用于存放==静态文件==，如Java类、方法等。永久代对垃圾回收没有显著影响，但是有些应用可能==动态生成或者调用一些class==，例如<u>反射，动态代理，CGLib等bytecode框架</u>时，在这种时候需要<u>设置一个比较大的永久代空间来存放这些运行过程中新增的类。</u></p>
<p>分代收集算法</p>
<p>safepoint</p>
<ul>
<li>分析过程中对象引用关系不会发生变化的点</li>
<li>产生safepoint的地方：方法调用；循环跳转；异常跳转</li>
<li>安全点数量得适中</li>
</ul>
<h5 id="垃圾回收算法总结"><a href="#垃圾回收算法总结" class="headerlink" title="垃圾回收算法总结"></a>垃圾回收算法总结</h5><p><img src="/.com//%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.png"></p>
<p>由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。垃圾回收有两种类型，Minor GC 和Full GC。</p>
<ul>
<li>Minor GC：对新生代进行垃圾回收，不会影响到老年代。因为新生代的Java对象大多都死亡频繁，所以MinorGC 非常频繁，一般在这里使用速度快、效率高的算法，使垃圾回收能尽快完成。</li>
<li>Full GC：也叫Major GC，对整个堆进行回收，包括新生代和老年代。由于Full GC 需要对整个堆进行回收，所以Minor GC要==慢==，因此应该尽可能减少Full GC的次数，导致Full GC 的原因包括：==老年代被写满、永久代（perm）被写满和Systen.gc()被显示调用==等。</li>
</ul>
<h5 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h5><p>垃圾收集器回收的是==无任何引用的对象占据的内存空间==而不是对象本身</p>
<p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是==内存回收的具体实现==。下图展示了其中作用于不同分代的收集器，其中用于**==回收新生代的收集器包括Serial、ParNew、Parallel Scavenge==<strong>,</strong>==回收老年代的收集器包括Serial Old、Paralled Old 、CMS==<strong>还有用于回收整个Java堆的</strong>==G1收集器==**。不同的收集器之间的连线表示他们可以搭配使用。</p>
<p><img src="/.com//%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg"></p>
<ul>
<li>【单线程–并行，并行×并行】</li>
<li>Serial 收集器（复制算法）：新生代单线程收集器，标记和清理都是单线程，优点是简单高效。</li>
<li>Serial Old收集器（标记-整理算法）：老年代单线程收集器，Serial收集器的老年代版本。</li>
<li>ParNew收集器（复制算法）：新生代并行收集器，实际上是==Serial收集器的多线程版本==，在多核CPU环境环境下有着比Serial更好的表现；</li>
<li>Parallel Scavenge收集器（复制算法）：新生代并行收集器，追求高吞吐量，高效利用CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台运用等对交互相应要求不高的场景。</li>
<li>Parallel Old 收集器（标记-整理算法）：老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；</li>
<li>CMS(Concurrent Mark Sweep) 收集器（==标记-清除算法==）：老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求GC回收停顿时间。</li>
<li>G1(Garbage First)收集器（标记-整理算法）：Java 堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G!收集器基于“标记-整理算法”实现，也就是说==不会产生内存碎片==。此外，G!收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆（包括新生代、老年代），而前六种收集器回收的范围仅限于新生代或老年代。</li>
</ul>
<h5 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h5><p>Java技术体系中所提倡的自动内存管理最终可以归结为自动化的解决了两个问题：给<strong>对象分配内存</strong>以及<strong>回收分配给对象的内存</strong></p>
<p>1、对象优先在Eden分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次MinorGC</p>
<p>2、==大对象直接进入老年代==。大对象是指需要大量连续内存空间的Java对象，最典型的大对象就是那种<u>很长的字符串以及数组</u></p>
<p>3、==长期存活的对象将进入老年代==。当对象在新生代中经历过一定次数（默认为15）的Minor GC后，就会被晋升到老年代中。</p>
<p>4、动态对象年龄判定。为了更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中==相同年龄==所有对象大小的总和==大于Survivor空间的一半==，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p>
<p>分代收集算法</p>
<p>触发Full GC的条件</p>
<ul>
<li>老年代空间不足</li>
<li>永久代空间不足</li>
<li>CMS GC时出现promotion failed，concurrent mode failure</li>
<li>Minor GC晋升到老年代的平均大小大于老年代的剩余空间</li>
<li>调用System.gc()</li>
<li>使用RMI来进行RPC或管理的JDK应用，每小时执行1次Full GC</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>集合类</title>
    <url>/%E9%9B%86%E5%90%88%E7%B1%BB/</url>
    <content><![CDATA[<h3 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h3><h4 id="常见的集合类："><a href="#常见的集合类：" class="headerlink" title="常见的集合类："></a>常见的集合类：</h4><ul>
<li><p>实现Collection接口的</p>
<p>Set List 以及他们的实现类</p>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>实现Map接口的</p>
<p>HashMap及其实现类</p>
</li>
</ul>
<ul>
<li><p>常用的</p>
<p>HashMap、HashTable、List、Set、ArrayList、HashSet</p>
</li>
</ul>
<h4 id="关系图表"><a href="#关系图表" class="headerlink" title="关系图表"></a>关系图表</h4><p><img src="images/%E9%9B%86%E5%90%88%E7%B1%BB.jpg" alt="集合类"></p>
<p><img src="images/%E9%9B%86%E5%90%88%E7%B1%BB%EF%BC%88Map%EF%BC%89.jpg" alt="集合类（Map）"></p>
<h4 id="Set-List-Map-区别联系"><a href="#Set-List-Map-区别联系" class="headerlink" title="Set List Map 区别联系"></a>Set List Map 区别联系</h4><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><ul>
<li><p>成员不能重复</p>
</li>
<li><p>实现类：HashSet、TreeSet、LinkedHashSet</p>
</li>
<li><p>HashSet</p>
<p> 操作：外部无序的遍历成员</p>
<p>成员要求：成员可为任意的Object子类的对象，但如果覆盖了equals方法，同时注意要修改hashCode方法</p>
</li>
</ul>
<ul>
<li><p>TreeSet</p>
<p>操作：外部有序的遍历成员，附加实现了SortedSet，支持子集等要求顺序的操作</p>
<p>成员要求：成员要求实现caparable接口，或者使用 Comparator构造TreeSet，成员一般为同一类型</p>
</li>
</ul>
<ul>
<li><p>LinkedHashSet</p>
<p>操作：外部按成员的插入顺序遍历成员</p>
<p>成员要求：成员与HashSet成员类似</p>
</li>
</ul>
<h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><ul>
<li><p>提供基于索引的队列成员的随机访问</p>
</li>
<li><p>实现类：ArrayList、LinkedList等</p>
</li>
<li><p>ArrayList</p>
<p>操作：提供快速的==基于索引==的成员访问，对尾部成员的增加和删除支持较好</p>
<p>成员要求：成员可为任意Object子类对象</p>
</li>
</ul>
<ul>
<li><p>LinkedList</p>
<p>操作：对列表中任何位置的成员的增加和删除支持较好，但对于基于索引的成员访问支持性能较差</p>
<p>成员要求：成员可为任意Object子类的对象</p>
</li>
</ul>
<h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><ul>
<li><p>保存键值对成员，基于键找值操作，compareTo或compare方法对键排序</p>
</li>
<li><p>实现类：HashMap、TreeMap、LinkedHashMap、IdentityHashMap、WeakHashMap</p>
</li>
<li><p>HashMap</p>
<p>操作：能满足用户对Map的通用需求</p>
<p>成员要求：键成员可为任意Object子类的对象，但如果覆盖了equals方法，同时注意修改hashCode方法</p>
</li>
</ul>
<ul>
<li><p>TreeMap</p>
<p>操作：支持对键有序的遍历，使用时建议先用HashMap增加和删除成员，最后从HashMap生成TreeMap;附加实现了SortedMap接口，支持子Map等要求顺序的操作</p>
<p>成员要求：键成员要求实现caparable接口或者使用comparator构造TreeMap，键成员一般为同一类型</p>
</li>
</ul>
<ul>
<li><p>LinkedHashMap</p>
<p>操作：<u>保留键的插入顺序</u>，用equals方法检查键和值得相等性</p>
<p>成员要求：成员可为任意Object子类的对象，但如果覆盖了equals方法，同时注意修改hashCode方法</p>
</li>
</ul>
<ul>
<li><p>IdentityHashMap</p>
<p>操作：使用==来检查键和值的相等性</p>
<p>成员要求：成员使用的是严格相等</p>
</li>
</ul>
<ul>
<li><p>WeakHashMap</p>
<p>操作：其行为依赖于垃圾回收线程，没有理由则少用</p>
</li>
</ul>
<h5 id="总观"><a href="#总观" class="headerlink" title="总观"></a>总观</h5><p>实现Collection接口的类，如Set和List，他们都是单值元素（其实Set内部也是采用Map来实现的，只是==键值一样==，从表面理解，就是单值），不像实现Map接口的类一样，里面存放的是key-value（键值对）形式的数据。这方面就会造成他们很多的不同点，如遍历方式，前者只能采用迭代或者循环来取值，但是后者可以使用键来获得键的值</p>
<p>Set接口不保证维护元素的顺序，而且元素不能重复。List接口维护元素的顺序，而且元素可以重复。</p>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><ul>
<li><p>Map 是Key-Value对映射的抽象接口。改映射不包括重复的键，即一个键对应一个值。简单地说，HashMap是基于哈希表的Map接口的实现，以Key-Value的形式存在，即存储的对象是==Entry==(To那个是包含了Key和Value)。</p>
</li>
<li><p>非线程安全，即任一时刻，可以有==多个线程同时写HashMap==,如需满足线程安全可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p>
</li>
<li><p>在HashMap中，其会根据==hash算法来计算key-value的存储位置==，并进行快速存取。</p>
</li>
<li><p>HashMap最多只允许一条Entry的键为Nul,但允许多条entry的值为Null即key最多只有一个为null而value没有限制</p>
</li>
<li><p>HashMap是Map的一个==非同步==的实现</p>
</li>
<li><p>HashMap与HashSet虽然实现的接口规范不同，但是他们底层的Hash存贮机制完全相同，实际上，HashSet本身就是在HashMap的基础上实现的。</p>
</li>
<li><p>虽然容器号称存贮的是Java对象，但实际上并不会真正将Java对象放入容器中，只是在容器中保留这些对象的引用。也就是说Java容器实际上包含的是==引用变量==，而这些引用变量指向了我们要实际保存的java对象。</p>
</li>
<li><p>JDK1.8引入==红黑树==大程度优化了HashMap的性能。</p>
<h4 id="HashMap-源码中的分析"><a href="#HashMap-源码中的分析" class="headerlink" title="HashMap 源码中的分析"></a>HashMap 源码中的分析</h4><p><code>哈希的相关概念：Hash就是把任意长度的输入（又叫预映射，pre-image），通过哈希算法，变换成固定长度的输出（通常是整型），该输出就是哈希值。这种转换是一种压缩映射,也就是说散列值的空间通常小于输入的空间。不同的输入可能会散列成相同的输出，从而不可能从散列值来唯一的确定输入值。简单的说，就是将任意长度的消息压缩到某一一固定长度的摘要函数</code></p>
<p><code>loadFactor:负载因子，用于衡量的是一个散列表的空间的使用程度</code></p>
<p><code>threshold:HashMap进行扩容的阈值，他的值等于HashMap的容量乘以负载因子</code></p>
<p><code>table:说明HashMap的底层实现仍是数组，只是数组的每一项都是一条链</code></p>
<p><code>初始容量和负载因子：这两个参数是影响HashMap性能的重要参数。其中容量拜师哈希表中桶的数量（table数组的大小）初始容量是创建哈希表时痛的数量；负载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，他衡量的是一个散列表的使用程度，负载因子越大表示散列表的装填程度越高，反之越小</code></p>
<p><code>HashMap的底层实现还是数组，只是数组的每一项都是一条链</code></p>
</li>
</ul>
<p>  <img src="https://img-blog.csdn.net/20170317181650025?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty HashMap with the default initial capacity</span></span><br><span class="line"><span class="comment">     * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//负载因子:用于衡量的是一个散列表的空间的使用程度</span></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line"></span><br><span class="line">        <span class="comment">//HashMap进行扩容的阈值，它的值等于 HashMap 的容量乘以负载因子</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// HashMap的底层实现仍是数组，只是数组的每一项都是一条链DEFAULT_INITIAL_CAPACITY是初始长度</span></span><br><span class="line">        table = <span class="keyword">new</span> Entry[DEFAULT_INITIAL_CAPACITY];<span class="comment">//table</span></span><br><span class="line"></span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>Entry（Node 1.8继承自Map.Entry）为HashMap的内部类，实现了Map.Entry接口，其包含了键Key、值value、下一个节点next、以及hash值四个属性。事实上，Entry是构成hash table的基石，是哈希表所存储的元素的具体形式</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> K key;     <span class="comment">// 键值对的键</span></span><br><span class="line">    V value;        <span class="comment">// 键值对的值</span></span><br><span class="line">    Entry&lt;K,V&gt; next;    <span class="comment">// 下一个节点</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;     <span class="comment">// hash(key.hashCode())方法的返回值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates new entry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;     <span class="comment">// Entry 的构造函数</span></span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java 1.8</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></span><br><span class="line"> </span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="HashMap快速存储"><a href="#HashMap快速存储" class="headerlink" title="HashMap快速存储"></a>HashMap快速存储</h5><p><code>HashMap中，最常用的操作就是put和get，在HashMap中key是惟一的。他保持唯一性首先不是通过equals方法进行比较，因为这种方法的时间复杂度是O(n)达不到HashMap快速存取的目的。实际上当我们put时，HashMap首先会调用Key的hashCode方法，然后基于此获取Key哈希码，通过哈希码快速找到某个桶即table数组中的位置，这个位置被称之为bucketIndex，如果两个对象的hashCode不同，那么equals一定为false。但是当其hashCode相同时，equals不一定为true。当这种情况发生时，我们称之为碰撞。碰撞发生后，会去除bucketIndex桶内已存储的元素，并通过hashCode()和equals方法来比较判断key是否已存在，如果存在则新的value替换旧的，不存在则存放新的键值对到桶中，所以equals方法只有在哈希码碰撞时才会用到。</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment"> * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment"> * value is replaced.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with key, or null if there was no mapping for key.</span></span><br><span class="line"><span class="comment"> *  Note that a null return can also indicate that the map previously associated null with key.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当key为null时，调用putForNullKey方法，并将该键值对保存到table的第一个位置 </span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据key的hashCode计算hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());             <span class="comment">//  ------- (1)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算该键值对在数组中的存储位置（哪个桶）</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);              <span class="comment">// ------- (2)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//在table的第i个桶上进行迭代，寻找 key 保存的位置</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;      <span class="comment">// ------- (3)</span></span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">//判断该条链上是否存在hash值相同且key值相等的映射，若存在，则直接覆盖 value，并返回旧value</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;    <span class="comment">// 返回旧值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++; <span class="comment">//修改次数增加1，快速失败机制</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//原HashMap中无该映射，将该添加至该链的链头</span></span><br><span class="line">    addEntry(hash, key, value, i);            </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="HashMap扩容机制"><a href="#HashMap扩容机制" class="headerlink" title="HashMap扩容机制"></a>HashMap扩容机制</h5><p><code>结合负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。</code></p>
<p><code>Java中的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   <span class="comment">//传入新的容量</span></span><br><span class="line">    Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;         </span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">        threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">    transfer(newTable);                         <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line">    table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);<span class="comment">//修改阈值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="HashMap的底层数组长度总是2的n次方的原因"><a href="#HashMap的底层数组长度总是2的n次方的原因" class="headerlink" title="HashMap的底层数组长度总是2的n次方的原因"></a>HashMap的底层数组长度总是2的n次方的原因</h5><p><code>我们知道，HashMap的底层数组长度总是2的n次方，原因是 HashMap 在其构造函数 HashMap(int initialCapacity, float loadFactor) 中作了特别的处理，如下面的代码所示。当底层数组的length为2的n次方时， h&amp;(length - 1) 就相当于对length取模，其效率要比直接取模高得多，这是HashMap在效率上的一个优化</code></p>
<ul>
<li><strong>不同的hash值发生碰撞的概率比较小，这样就会使得数据在table数组中分布较均匀，空间利用率较高，查询速度也较快；</strong></li>
<li><strong>h&amp;(length - 1) 就相当于对length取模，而且在速度、效率上比直接取模要快得多，即二者是等价不等效的，这是HashMap在速度和效率上的一个优化。</strong></li>
</ul>
<p>由于是双倍扩容，迁移过程中，会将原来 table[i] 中的链表的所有节点，分拆到新的数组的 newTable[i] 和 newTable[i + oldLength] 位置上。如原来数组长度是 16，那么扩容后，原来 table[0] 处的链表中的所有元素会被分配到新数组中 newTable[0] 和 newTable[16] 这两个位置。</p>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><ul>
<li>LinkedList 底层采用双向循环列表实现，进行插入和删除操作时具有较高的速度，可以使用LinkedList来实现队列和栈。但是在随机访问方面效率不高</li>
<li>LinkedList 继承了AbstractSequentialList接口，AbstractSequentialList相比于AbstractList只支持次序访问1而不支持随机访问，因为前者的get(int index),set(int index,E element),add(int index,E element),remove(int index)都是基于迭代器实现的，所以在LinkedList使用迭代器遍历更快，而ArrayList使用get(i)更快。</li>
</ul>
<h5 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h5><p><code>transient int size = 0;//计数 链表中的节点个数</code></p>
<p><code>transient Node&lt;E&gt; first;// 头节点指针</code></p>
<p><code>transient Node&lt;E&gt; last;// 尾节点指针</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">  E item;</span><br><span class="line">  Node&lt;E&gt; next;</span><br><span class="line">  Node&lt;E&gt; prev;</span><br><span class="line">  Node(Node&lt;E&gt; prev,E element,Node&lt;E&gt; next)&#123;</span><br><span class="line">    <span class="keyword">this</span>.item = element;<span class="comment">//当前节点值</span></span><br><span class="line">    <span class="keyword">this</span>.next = next;<span class="comment">//后继节点</span></span><br><span class="line">    <span class="keyword">this</span>.prev = prev;<span class="comment">//前驱节点</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="插入与删除"><a href="#插入与删除" class="headerlink" title="插入与删除"></a>插入与删除</h5><ul>
<li><p>获取节点</p>
<p>getFirst()、getList()、get(int index);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *检查非空后，直接返回first节点的item</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">  <span class="keyword">if</span>(f==<span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">  <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *检查非空后，直接返回last节点的item</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">  <span class="keyword">if</span>(l == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">  <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;<span class="comment">//indexOf LastIndexof同理</span></span><br><span class="line">  checkElementIndex(index);<span class="comment">//checkElemetIndex中主要用到isElementIndex方法</span></span><br><span class="line">  <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;<span class="comment">//事实证明确实是迭代取值</span></span><br><span class="line">  <span class="keyword">if</span>(index &lt;(size&gt;&gt;<span class="number">1</span>))&#123;<span class="comment">//判断index是在链表偏左侧还是偏右侧</span></span><br><span class="line">    Node&lt;E&gt; x = first;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;index;i++)</span><br><span class="line">      x = x.next;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    Node&lt;E&gt; x = last;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = size-<span class="number">1</span>;i&gt;index;i--)</span><br><span class="line">      x = x.prev;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置节点</p>
<p>set(int index),add(int index,E element),addFirst(E e),addLast(E e);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index,E element)</span></span>&#123;</span><br><span class="line">  checkElemetIndex(index);</span><br><span class="line">  Node&lt;E&gt; x = node(index);</span><br><span class="line">  E oldVal = x.item;</span><br><span class="line">  x.item = element;<span class="comment">//根据node返回的对象直接赋值就能更改，我认为是node函数返回的就是那个对象，而x是引用，索引当用x.item进行赋值时实际上将堆内存中的内容改变。</span></span><br><span class="line">  <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,E element)</span></span>&#123;<span class="comment">//实际就是在指定前插入一个新的节点，并将旧的节点的prev设置为这个新的节点，旧的节点前的节点的next指向新的节点。</span></span><br><span class="line">  checkPositionIndex(index);</span><br><span class="line">  <span class="keyword">if</span> (index == size)</span><br><span class="line">    linkLast(element);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//addFirst、addList很简单不做赘述</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="与ArrayList"><a href="#与ArrayList" class="headerlink" title="与ArrayList"></a>与ArrayList</h5><p>相同点：都实现了Collection接口</p>
<p>不同点：ArrayList基于数组，具有较高的查询速度，而LinkedList基于双向循环链表，具有较快的添加或者删除的速度，</p>
<h4 id="两两对比"><a href="#两两对比" class="headerlink" title="两两对比"></a>两两对比</h4><h5 id="HashMap和HashTable"><a href="#HashMap和HashTable" class="headerlink" title="HashMap和HashTable"></a><strong>HashMap和HashTable</strong></h5><p>相同点：两者都实现了Map接口，因此具有一系列Map接口提供的发法</p>
<p>不同点：</p>
<p>HashMap继承了AbstractMap，而HashTable继承了Dictionary。</p>
<p> HashMap非线程安全，HashTable线程安全，到处都是synchronized关键字。</p>
<p>因为HashMap没有同步，所以处理起来效率较高。</p>
<p>HashMap键、值都允许为null，HashTable键、值都不允许有null。</p>
<p>HashTable使用Enumeration，HashMap使用Iterator。</p>
<h5 id="Set-和List"><a href="#Set-和List" class="headerlink" title="Set 和List"></a>Set 和List</h5><p>相同点：都实现了Collection接口</p>
<p>不同点：</p>
<p>Set接口不保证维护元素的顺序，并且元素不能重复。List维护元素第二顺序，元素可以重复</p>
<h5 id="SortedSet-和SortedMap"><a href="#SortedSet-和SortedMap" class="headerlink" title="SortedSet 和SortedMap"></a>SortedSet 和SortedMap</h5><p>两者都提供了排序的功能</p>
<h5 id="TreeMap和HashMap"><a href="#TreeMap和HashMap" class="headerlink" title="TreeMap和HashMap"></a>TreeMap和HashMap</h5><p>HashMap具有较高的速度（查询）,TreeMap则提供了按照键进行排序的功能。</p>
<h5 id="HashSet和LinkedHashSet"><a href="#HashSet和LinkedHashSet" class="headerlink" title="HashSet和LinkedHashSet"></a>HashSet和LinkedHashSet</h5><p>HashSet,为快速查找而设计的set，存入HashSet的对象必须实现hashCode和equals</p>
<p>LinkedHashSet，具有HashSet的查询速度，且内部使用链表维护元素的顺序（插入的顺序），于是在使用迭代器遍历Set时，结果会按照元素插入的次序显示</p>
<h5 id="TreeSet和HashSet"><a href="#TreeSet和HashSet" class="headerlink" title="TreeSet和HashSet"></a>TreeSet和HashSet</h5><p>TreeSet提供排序功能的Set，底层为树结构，相比较HashMap查询速度滴，如果只是元素的查询，我们一般使用HashSet</p>
<h5 id="ArrayList和Vector"><a href="#ArrayList和Vector" class="headerlink" title="ArrayList和Vector"></a>ArrayList和Vector</h5><p>同步性：Vector是线程安全的，也就是说同步的，而ArrayList是线程不安全的，不是同步的。</p>
<p>数据增长：当需要增长时，Vector默认增长为原来的一倍，而ArrayList确实原来的一半</p>
<h5 id="Collection和Collections"><a href="#Collection和Collections" class="headerlink" title="Collection和Collections"></a>Collection和Collections</h5><p>Collection是一些列单值集合类的负借口，提供了基本的一些方法，而Collections则是一系列算法的集合。里面的属性和方法基本都是static的，也就是不需要实例化，直接可以使用类名来调用。</p>
<p>collections可以生成单元素集合（</p>
<p>Collections中的单元素集合指的是集合中只有一个元素而且集合只读。<br>Collections.singletonList——用来生成只读的单一元素的List<br>Collections.singletonMap——用来生成只读的单Key和Value组成的Map</p>
<p>Collections.singleton——用来生成只读的单一元素的Set</p>
<p>）</p>
<p>Checked集合、同步集合（为一些非线程安全的集合类提供同步机制）查找替换、集合排序</p>
]]></content>
  </entry>
</search>
